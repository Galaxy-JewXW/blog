# 编译实验优化文档

代码优化可分为机器无关的中端优化与机器相关的后端优化。以下介绍我的编译器`PlatoCompiler`实现的优化方法。

## 中端优化

### SSA：静态单赋值

在处理栈或局部变量时，编译器前端通过 alloca 指令将每个局部变量映射到栈上一个对应的空间，将读写映射为对应空间的 load/store 指令。例如以下的指令：

```c
int main() {
    int x, cond;
    cond = getint();
    if (cond > 0){
        x = 1;
    }
    else{
        x = -1;
    }
    printf("%d", x);
    return 0;
}
```
翻译出来的LLVM IR是：

```
define dso_local i32 @main() {
b0:
	%v1 = alloca i32
	%v2 = alloca i32
	%v3 = call i32 @getint()
	store i32 %v3, i32* %v2
	%v4 = load i32, i32* %v2
	%v5 = icmp sgt i32 %v4, 0
	br i1 %v5, label %b6, label %b7
b6:
	store i32 1, i32* %v1
	br label %b9
b7:
	%v8 = sub i32 0, 1
	store i32 %v8, i32* %v1
	br label %b9
b9:
	%v10 = load i32, i32* %v1
	call void @putint(i32 %v10)
	ret i32 0
}
```

这种方案简化了前端设计，但是在中间代码上需要进行相关优化时，大量的alloca/load/store指令导致编译器需要跟踪记录变量在栈空间上的位置，这种非SSA形式使得分析def-use关系会变得更加复杂，因此需要消除这些不必要的内存操作。

上述代码的SSA形式为：

```
define dso_local i32 @main() {
b0:
	%v1 = call i32 @getint()
	%v2 = icmp sgt i32 %v1, 0
	br i1 %v2, label %b3, label %b6
b3:
	br label %b4
b4:
	%v5 = phi i32 [ 1, %b3 ], [ -1, %b6 ]
	call void @putint(i32 %v5)
	ret i32 0
b6:
	br label %b4
}
```

为了将非SSA的IR转换为SSA形式，可以采用Mem2Reg的方法。Mem2Reg的核心在于

- 在支配边界（恰好支配不到的基本块）插入phi指令
- 插入phi后进行重命名

为了得到支配边界，我们首先需要构建函数的CFG；构建CFG之前，首先要做的是删除不可达基本块。

### 删除不可达基本块

在IR中可能出现以下的语句：

```
b10:
	br label %b8
	br label %b14
```

此时`br label %14`是不可达的语句，需要将终结语句`br label %b8`之后的代码删除

完成该步骤之后，对每个函数，从第一个基本块开始，根据每个基本块的最后一条语句（一定是终结语句）进行dfs，搜索可能到达的基本块，并删除其他的基本块。

```java
private static void simplifyFunction(Function func) {
    func.getBasicBlocks().forEach(SurplusBlock::deleteDeadInstr);
    visited = new HashSet<>();
    dfs(func.getEntryBlock());
    func.getBasicBlocks().removeIf(block -> {
        if (!visited.contains(block)) {
            block.getInstructions().forEach(Instruction::removeOperands);
            block.removeOperands();
            block.setDeleted(true);
            return true;
        }
        return false;
    });
}

private static void dfs(BasicBlock block) {
    if (!visited.add(block)) {
        return;
    }
    Instruction lastInstruction = block.getLastInstruction();
    if (lastInstruction instanceof BrInst brInst) {
        if (brInst.isConditional()) {
            dfs(brInst.getTrueBlock());
            dfs(brInst.getFalseBlock());
        } else {
            dfs(brInst.getTrueBlock());
        }
    }
}
```

### Mem2Reg

教程中介绍了对于每个变量v，通过求出$DF^+(Def_v)$就知道了插入phi函数的位置。为了求出DF（支配边界），对于每个函数`Function`，我们采用以下步骤进行计算：

1. 计算CFG图

   每个基本块都以一个终结语句结尾，与删除不可达基本块类似，通过每一个基本块的终结语句计算该基本块的前驱基本块和后继基本块。

   ```java
   private static void calcControlFlowGraph() {
       for (BasicBlock block : currentFunction.getBasicBlocks()) {
           Instruction lastInstruction = block.getLastInstruction();
           if (lastInstruction instanceof BrInst brInst) {
               if (brInst.isConditional()) {
                   addEdge(block, brInst.getTrueBlock());
                   addEdge(block, brInst.getFalseBlock());
               } else {
                   addEdge(block, brInst.getTrueBlock());
               }
           }
       }
       for (BasicBlock block : currentFunction.getBasicBlocks()) {
           block.setNextBlocks(childBlocks.get(block));
           block.setPrevBlocks(parentBlocks.get(block));
       }
   }
   
   private static void addEdge(BasicBlock from, BasicBlock to) {
       childBlocks.get(from).add(to);
       parentBlocks.get(to).add(from);
   }
   ```

2. 计算支配树

   - 利用定义计算支配关系：在dfs中，如果在遍历时遇到`dominator`自己，就不再继续递归下去。这相当于在控制流图中“屏蔽”了`dominator`，测试在没有穿过该块的前提下，能到达哪些块。如果不能访问到基本块`block`，那么`dominator`就是`block`的支配块。
   - 计算直接支配：如果在`dominated`被支配的所有块中，有另外一个块`otherDominator`同时被`dominator`支配，则`dominator`可能并不是距离`dominated`最近的支配者，因为`otherDominator`夹在中间。A支配C且A支配B，C支配B时，则A不是B的直接支配，而C才是。

   ```java
   private static void calcDominatorTree() {
       BasicBlock entry = currentFunction.getBasicBlocks().get(0);
       for (BasicBlock dominator : currentFunction.getBasicBlocks()) {
           Set<BasicBlock> reachableBlocks = new HashSet<>();
           dfs(entry, dominator, reachableBlocks);
           for (BasicBlock block : currentFunction.getBasicBlocks()) {
               if (!reachableBlocks.contains(block)) {
                   dominates.get(dominator).add(block);
                   dominatedBy.get(block).add(dominator);
               }
           }
           dominator.setDominateBlocks(dominates.get(dominator));
       }
       for (BasicBlock dominated : currentFunction.getBasicBlocks()) {
           for (BasicBlock dominator : dominatedBy.get(dominated)) {
               if (isImmediateDominator(dominator, dominated)) {
                   dominated.setImmediateDominator(dominator);
                   immediatelyDominates.get(dominator).add(dominated);
                   break;
               }
           }
       }
       for (BasicBlock block : currentFunction.getBasicBlocks()) {
           block.setImmediateDominateBlocks(immediatelyDominates.get(block));
       }
   }
   
   private static void dfs(BasicBlock current, BasicBlock dominator, Set<BasicBlock> reachableBlocks) {
       reachableBlocks.add(current);
       if (current.equals(dominator)) {
           return;
       }
       for (BasicBlock child : current.getNextBlocks()) {
           if (!reachableBlocks.contains(child)) {
               dfs(child, dominator, reachableBlocks);
           }
       }
   }
   
   private static boolean isImmediateDominator(BasicBlock dominator, BasicBlock dominated) {
       for (BasicBlock otherDominator : dominatedBy.get(dominated)) {
           if (otherDominator != dominator
                   && dominates.get(dominator).contains(otherDominator)) {
               return false;
           }
       }
       return true;
   }
   ```

   > 以上算法的时间复杂度较高，可考虑Lengauer-Tarjan算法来优化效率

3. 计算支配边界

   对于每一个被`dominator`支配的块`dominated`，查看它的直接后继块`child`。如果这个`child`不在`dominator`支配的集合中，说明该`child`位于`dominator`所支配区域之外。由于`child`直接跟`dominated`相连，而`dominated`受`dominator`支配，但是`child`不受`dominator`支配，那么`child`就是支配边界中的一员（形成了支配区域与非支配区域之间的边界）。

   如果`dominator`的直接后继也不受`dominator`支配，那么该后继块也可视为支配边界的一部分。

   ```java
   private static void calcDominanceFrontier() {
       for (BasicBlock dominator : currentFunction.getBasicBlocks()) {
           ArrayList<BasicBlock> frontier = new ArrayList<>();
           for (BasicBlock dominated : dominator.getDominateBlocks()) {
               for (BasicBlock child : dominated.getNextBlocks()) {
                   if (!dominator.getDominateBlocks().contains(child)
                           && !frontier.contains(child)) {
                       frontier.add(child);
                   }
               }
           }
           for (BasicBlock child : dominator.getNextBlocks()) {
               if (!dominator.getDominateBlocks().contains(child)
                       && !frontier.contains(child)) {
                   frontier.add(child);
               }
           }
           dominator.setDominanceFrontier(frontier);
       }
   }
   ```

4. 计算def集合和use集合

   对于`Function`中的每一个alloca指令（不考虑数组），通过`User-Use-Value`关系，对其所有的使用者进行分类。`useInstructions`存放所有对该变量的读取（`load`）指令。`defInstructions`存放所有对该变量的定义（`store`）指令。`defBlocks`记录所有存在该变量定义（`store`）的基本块。

5. 插入phi

   按照伪代码进行操作即可。

   ![1.png](https://drinkwater-1325041233.cos.ap-guangzhou.myqcloud.com/imgs/wvPf9pKkCDtAZy3.png)

   一种可能的实现如下：

   ```java
   private static void insertPhi() {
       HashSet<BasicBlock> F = new HashSet<>();
       ArrayList<BasicBlock> W = new ArrayList<>(defBlocks);
       while (!W.isEmpty()) {
           BasicBlock X = W.remove(0);
           for (BasicBlock Y : X.getDominanceFrontier()) {
               if (!F.contains(Y)) {
                   PhiInst phiInst = new PhiInst(currentAlloc.getTargetType(),
                           Y, new ArrayList<>(Y.getPrevBlocks()));
                   Y.getInstructions().add(0, phiInst);
                   useInstructions.add(phiInst);
                   defInstructions.add(phiInst);
                   F.add(Y);
                   if (!defBlocks.contains(Y)) {
                       W.add(Y);
                   }
               }
           }
       }
   }
   ```

6. 变量重命名

   参考教程提供的伪代码，通过遍历支配树来进行，给每个单独的存活区间一个新的变量名。

   - 当遇到store时，将store的值压入栈（defStack），表示变量在此处有了一个新版本
   - 当遇到load时，用栈顶的值替换load指令（即用当前最新版本的变量值），从而消除对内存的读取
   - 当遇到phi时，也将phi节点作为新定义压入栈中，以便后续使用
   - 对所有后继基本块的phi指令设置来自当前块的值，如果defStack为空，设置为Undefined。这种情况为UB，在我的编译器中是设为0。
   - 当离开该基本块时，将在该块中所推入的定义值从栈中弹出，以保持栈的正确性
   - 删除已被处理的alloca/load/store指令

   ```java
   private static void renameVariables(BasicBlock block) {
       Iterator<Instruction> it = block.getInstructions().iterator();
       int pushCount = 0;
       while (it.hasNext()) {
           Instruction instruction = it.next();
           if (instruction.equals(currentAlloc)) {
               it.remove();
           } else if (instruction instanceof LoadInst
                   && useInstructions.contains(instruction)) {
               Value newValue = defStack.empty() ? new Undefined() : defStack.peek();
               instruction.replaceByNewValue(newValue);
               it.remove();
           } else if (instruction instanceof StoreInst storeInst
                   && defInstructions.contains(instruction)) {
               defStack.push(storeInst.getStoredValue());
               instruction.removeOperands();
               pushCount++;
               it.remove();
           } else if (instruction instanceof PhiInst
                   && defInstructions.contains(instruction)) {
               pushCount++;
               defStack.push(instruction);
           }
       }
       for (BasicBlock child : block.getNextBlocks()) {
           Instruction firstInstruction = child.getFirstInstruction();
           if (firstInstruction instanceof PhiInst phiInst && useInstructions.contains(firstInstruction)) {
               Value value = defStack.empty() ? new Undefined() : defStack.peek();
               phiInst.addValue(block, value);
           }
       }
       for (BasicBlock dominated : block.getImmediateDominateBlocks()) {
           renameVariables(dominated);
       }
       for (int i = 0; i < pushCount; i++) {
           defStack.pop();
       }
   }
   ```

### 函数副作用分析

对所有函数进行分析，没有副作用的函数（pure function）可以进行更多的优化。

判断一个函数有副作用的判定标准为：

1. 存在IO相关指令：IO会对外部状态产生影响
2. 写全局变量：改变Module的全局状态
3. 写通过`FuncParam`或`GlobalVar`间接引用的内存：通过参数或全局引用（如数组指针）对外部可见状态进行了修改
4. 调用有副作用的函数

在代码实现上，第一遍扫描后，可能有一些函数调用了有副作用的函数，但是自身状态没有更新，此时需要对函数的调用关系进行传递。

### 函数内联

函数内联通过被调用的函数体直接“复制”到调用处，从而消除函数调用的开销，同时为后续优化创造机会。

1. 构建调用图

   ```java
   private static void initializeCallGraphs() {
       callGraph = new HashMap<>();
       reverseCallGraph = new HashMap<>();
   
       module.getFunctions().forEach(func -> {
           callGraph.put(func, new HashSet<>());
           reverseCallGraph.put(func, new HashSet<>());
       });
   
       module.getFunctions().forEach(func ->
               func.getBasicBlocks().stream()
                       .flatMap(block -> block.getInstructions().stream())
                       .filter(instr -> instr instanceof CallInst)
                       .map(instr -> (CallInst) instr)
                       .forEach(callInst -> {
                           Function target = callInst.getCalledFunction();
                           callGraph.get(func).add(target);
                           reverseCallGraph.get(target).add(func);
                       })
       );
   }
   ```

2. 判断是否需要内联，需要满足

   - 不是main函数
   - 函数被调用，且函数不调用其他函数（叶子函数）
   - 不存在递归

   如果上述条件都满足，则找出所有对该function的调用点。

   ```java
   ArrayList<CallInst> calls = reverseCallGraph.get(function).stream()
               .flatMap(caller -> caller.getBasicBlocks().stream())
               .flatMap(block -> block.getInstructions().stream())
               .filter(instr -> instr instanceof CallInst)
               .map(instr -> (CallInst) instr)
               .filter(callInst -> callInst.getOperands().get(0).getName().equals(function.getName()))
               .collect(Collectors.toCollection(ArrayList::new));
   ```

3. 分裂基本块：在调用指令所在的基本块之后新建一个基本块nextBlock，将call指令之后的指令移动到nextBlock，并删除call指令。这样做的原因是为了方便在插入被调函数的代码后，可以无缝衔接原来的控制流。

   分裂基本块后需要更新phi指令的前趋基本块信息。

4. 对被调用的函数代码进行深拷贝得到`copiedFunction`，将被调用函数的形式参数用调用指令的实参替换，在原来call指令的位置插入无条件跳转指令，跳转至`copiedFunction`的入口基本块，将`copiedFunction`的基本块插入。

5. 处理`copiedFunction`的`RetInst`：

   - 如果返回类型是`void`，将返回点转化为无条件跳转到nextBlock；
   - 如果有非void返回值，在nextBlock开头插入phi结点，用原本`RetInst`的返回值作为phi的操作数。

6. 每次会根据当前的调用图重新判断是否有新的函数可以内联。一旦有函数被内联修改了模块，则可能解开更多内联机会。

   再次循环，直到没有更多可内联的函数。

### 全局变量本地化

全局变量本地化的目的是将全局变量转换为更局部的形式（如函数内的局部变量），优化对全局变量的存取操作，同时暴露更多的优化机会。

1. 检查全局变量的使用情况

   在`PlatoCompiler`中，一个`Module`由多个`Function`和多个`GlobalVar`组成。对于每个`GlobalVar`，检查其在哪些函数中被使用。

   ```java
   private static void checkUse(Module module) {
       for (GlobalVar gv : module.getGlobalVars()) {
           for (User user : gv.getUserList()) {
               Function func = ((Instruction) user)
                       .getBasicBlock().getFunction();
               usedMap.computeIfAbsent(gv, k -> new HashSet<>()).add(func);
           }
       }
   }
   ```

2. 构建函数调用图

3. 采取保守的策略，将满足以下条件的全局变量进行本地化处理：

   - 类型为`i8`或`i32`
   - 只在某一个函数`func`中被使用，且`func`没有被其他函数调用

   本地化的操作步骤为：

   1. 根据全局变量类型创建alloca语句，插入入口基本块

      ```java
      BasicBlock entryBlock = func.getEntryBlock();
      ValueType gvType = ((PointerType) gv.getValueType()).getTargetType();
      AllocInst allocInst = new AllocInst(gvType);
      allocInst.setBasicBlock(entryBlock);
      entryBlock.getInstructions().add(0, allocInst);
      ```

   2. 插入store语句，根据初始值设置新变量的初始值，缺省为0

      ```java
      int initValue;
      VarSymbol varSymbol = (VarSymbol) TableManager.getInstance1()
              .getSymbol(gv.getName().substring(1));
      InitialValue initialValue = varSymbol.getInitialValue();
      if (initialValue.getElements() == null) {
          initValue = 0;
      } else {
          initValue = varSymbol.getConstValue();
      }
      StoreInst storeInst = new StoreInst(allocInst, new ConstInt(gvType, initValue));
      storeInst.setBasicBlock(entryBlock);
      entryBlock.getInstructions().add(1, storeInst);
      ```

   3. 将对全局变量的所有使用替换为新分配的局部变量，移除该全局变量

      ```java
      gv.replaceByNewValue(allocInst);
      toRemove.add(gv);
      ```

以上对一般的全局变量本地化替换策略较为保守，是因为在某些情况下，过于激进的优化会导致全局变量在其他函数中的使用仍然存在，使得部分函数依赖于该全局变量而另一些函数则不再使用，从而导致程序的语义发生改变。但是假设该全局变量满足一些特殊条件，那么可以采取另外的优化方法

#### 全局常变量优化

对于定义在全局的常变量`const int a = 4`，其值不会再发生改变，于是可将所有使用到全局常变量的load指令替换为一个常数，例如所有的`%v2 = load i32, i32* @a`，我们可以直接得到`%v2`的值是4。

```java
// gv的valuetype默认是指针类型
ValueType gvType = ((PointerType) gv.getValueType()).getTargetType();
if (gvType.equals(IntegerType.i8) || gvType.equals(IntegerType.i32)) {
    int initValue;
    InitialValue initialValue = varSymbol.getInitialValue();
    if (initialValue.getElements() == null) {
        initValue = 0;
    } else {
        initValue = varSymbol.getConstValue();
    }
    ConstInt constInt = new ConstInt(gvType, initValue);
    for (User user : gv.getUserList()) {
        if (user instanceof LoadInst loadInst) {
            loadInst.replaceByNewValue(constInt);
            toRemove.add(gv);
            loadInst.getBasicBlock().getInstructions().remove(loadInst);
        }
    }
}
```

#### 全局常数组优化

对常数组`const int a[3] = {1, 2, 3}`，与常变量类似，可以将常数下标数组访问替换为具体值，如`int b = a[2]`可以直接替换为`int b = 3`。

需要注意考虑下标非常数的情况，比如`int c = a[b]`。

```java
ValueType gvType = ((PointerType) gv.getValueType()).getTargetType();
if (!(gvType instanceof ArrayType arrayType)) {
    continue;
}
gvType = arrayType.getElementType();
if (gvType.equals(IntegerType.i8) || gvType.equals(IntegerType.i32)) {
    for (User user : gv.getUserList()) {
        if (user instanceof GepInst gepInst) {
            if (gepInst.getIndex() instanceof ConstInt constInt) {
                int index = constInt.getIntValue();
                for (User user1 : gepInst.getUserList()) {
                    if (user1 instanceof LoadInst loadInst) {
                        int intValue;
                        if (index < varSymbol.getInitialValue().getElements().size()) {
                            intValue = varSymbol.getConstValue(index);
                        } else {
                            intValue = 0;
                        }
                        ConstInt constInt1 = new ConstInt(gvType, intValue);
                        loadInst.replaceByNewValue(constInt1);
                        loadInst.getBasicBlock().getInstructions().remove(loadInst);
                    }
                }
            }
        }
    }
}
```

以上对于全局常数组的优化同样适用于局部常数组，方法类似，在此不再赘述。

### 代码删除

代码删除通过遍历有用函数中的每条指令，并沿着def-use链构建有用指令的**闭包**，删除不在闭包的指令。

```java
private static void delete(Function function) {
    HashSet<Instruction> usefulInstructions = findUseful(function);
    removeUseless(function, usefulInstructions);
}

// 查找有用的指令
private static HashSet<Instruction> findUseful(Function function) {
    HashSet<Instruction> useful = new HashSet<>();
    function.getBasicBlocks().forEach(block ->
            block.getInstructions().stream()
                    .filter(CodeRemoval::isUseful)
                    .forEach(instruction -> getClosure(instruction, useful))
    );
    return useful;
}

// 获取所有依赖关系的闭包
private static void getClosure(Instruction instruction, HashSet<Instruction> useful) {
    Stack<Instruction> stack = new Stack<>();
    stack.push(instruction);
    while (!stack.isEmpty()) {
        Instruction curInstruction = stack.pop();
        if (useful.add(curInstruction)) {
            curInstruction.getOperands().stream()
                    .filter(operand -> operand instanceof Instruction)
                    .map(operand -> (Instruction) operand)
                    .forEach(stack::push);
        }
    }
}

private static boolean isUseful(Instruction instruction) {
    // 判断指令是否有用
}

// 移除无用的指令
private static void removeUseless(Function function, HashSet<Instruction> useful) {
    function.getBasicBlocks().forEach(block ->
            block.getInstructions().removeIf(instruction -> {
                if (!useful.contains(instruction)) {
                    instruction.removeOperands();
                    return true;
                }
                return false;
            })
    );
}
```

除此之外，该阶段还可以完成**无用函数删除、无用数组删除**等工作。

### GVN

GVN通过为每个唯一的计算分配一个值编号，确保相同计算只执行一次，并重用其结果。这样的“值编号”分配可以使用指令的哈希值进行。

1. 对每条指令生成唯一的哈希值：在LLVM IR中，可对计算语句、指针计算语句、函数调用语句、截断与扩展语句进行处理。

   由于计算语句存在左右两个变量，对于满足交换律的加法和乘法，对左右变量顺序进行调整，使得`a + b`和`b + a`可被识别为公共表达式；对于`icmp`逻辑计算语句，也可以通过类似的方法，将`b > a`转化为`a < b`。

   对于可处理的`call`语句，需要额外判断所调用的函数是否有潜在副作用。

   ```java
   private static String getHash(Instruction instruction) {
       if (instruction instanceof BinaryInst binaryInst) {
           String lName = binaryInst.getOperand1().getName();
           String rName = binaryInst.getOperand2().getName();
           String op = binaryInst.getOpType().toString();
           if (!OperatorType.isLogicalOperator(binaryInst.getOpType())) {
               if (binaryInst.getOpType() == OperatorType.ADD
                       || binaryInst.getOpType() == OperatorType.MUL) {
                   if (lName.compareTo(rName) > 0) {
                       return rName + " " + op + " " + lName;
                   } else {
                       return lName + " " + op + " " + rName;
                   }
               }
           } else {
               OperatorType temp = binaryInst.getOpType();
               if (lName.compareTo(rName) < 0) {
                   lName = binaryInst.getOperand2().getName();
                   rName = binaryInst.getOperand1().getName();
                   temp = switch (temp) {
                       case ICMP_SGE -> OperatorType.ICMP_SLE;
                       case ICMP_SGT -> OperatorType.ICMP_SLT;
                       case ICMP_SLT -> OperatorType.ICMP_SGT;
                       case ICMP_SLE -> OperatorType.ICMP_SGE;
                       default -> temp;
                   };
               }
               return lName + " " + temp.toString() + " " + rName;
           }
       } else if (instruction instanceof GepInst gepInst) {
           return gepInst.getPointer().getName() + " "
                   + gepInst.getIndex().getName();
       } else if (instruction instanceof CallInst callInst && callCanReplaced(callInst)) {
           return callInst.getCallee();
       } else if (instruction instanceof TruncInst truncInst) {
           return truncInst.getOriginValue().getName() + " trunc "
                   + truncInst.getOriginValue().getValueType() + " -> " + truncInst.getValueType();
       } else if (instruction instanceof ZextInst zextInst) {
           return zextInst.getOriginValue().getName() + " zext "
                   + zextInst.getOriginValue().getValueType() + " -> " + zextInst.getValueType();
       }
       return null;
   }
   ```

2. 如果哈希值已存在，说明当前指令是冗余的，可以用已有的值替换，并移除该指令。

   当前基本块处理完成后，递归处理支配树中的子基本块，确保全局范围内的等价指令都能被识别。在退出当前基本块后，移除在该基本块中插入的哈希值，避免影响其他独立的控制流路径。

   ```java
   private static void visitBlock(BasicBlock block) {
       ArrayList<Instruction> instructions = new ArrayList<>(block.getInstructions());
       HashSet<String> inserted = new HashSet<>();
   
       instructions.forEach(instr -> {
           String gvnHash = getHash(instr);
           if (gvnHash != null) {
               if (gvnMap.containsKey(gvnHash)) {
                   instr.replaceByNewValue(gvnMap.get(gvnHash));
                   block.getInstructions().remove(instr);
                   instr.removeOperands();
               } else {
                   gvnMap.put(gvnHash, instr);
                   inserted.add(gvnHash);
               }
           }
       });
   
       block.getImmediateDominateBlocks().forEach(GVN::visitBlock);
       inserted.forEach(gvnMap::remove);
   }
   ```

### 常量折叠

常量折叠可进行的优化较多。

1. 对于截断与扩展指令，如果操作数是常量，则可以直接将值替换为对应位数的值。

   ```java
   private static void zextOptimize(ZextInst zextInst) {
       Value origin = zextInst.getOriginValue();
       if (origin instanceof ConstInt constInt) {
           int value = constInt.getIntValue();
           ValueType targetType = zextInst.getValueType();
           if (targetType.equals(IntegerType.i8) || targetType.equals(IntegerType.i32)) {
               ConstInt constInt1 = new ConstInt(targetType, value);
               zextInst.replaceByNewValue(constInt1);
               zextInst.removeOperands();
               curBlock.getInstructions().remove(zextInst);
           }
       }
   }
   
   private static void truncOptimize(TruncInst truncInst) {
       Value origin = truncInst.getOriginValue();
       if (origin instanceof ConstInt constInt) {
           int value = constInt.getIntValue();
           ValueType targetType = truncInst.getValueType();
           if (targetType.equals(IntegerType.i8) && constInt.getValueType().equals(IntegerType.i32)) {
               ConstInt constInt1 = new ConstInt(targetType, value & 0xFF);
               truncInst.replaceByNewValue(constInt1);
               truncInst.removeOperands();
               curBlock.getInstructions().remove(truncInst);
           }
       }
   }
   ```

2. `a % b = a - a / b * b（b为常数）`，方便后端进行乘除优化

   ```java
   private static void srem2div(BinaryInst inst) {
       Value a = inst.getOperand1();
       Value b = inst.getOperand2();
       BasicBlock curBlock = inst.getBasicBlock();
       if (!(a instanceof ConstInt) && (b instanceof ConstInt)) {
           BinaryInst div = new BinaryInst(OperatorType.SDIV, a, b);
           BinaryInst mul = new BinaryInst(OperatorType.MUL, div, b);
           BinaryInst sub = new BinaryInst(OperatorType.SUB, a, mul);
           div.setBasicBlock(curBlock);
           mul.setBasicBlock(curBlock);
           sub.setBasicBlock(curBlock);
           curBlock.getInstructions().set(curBlock.getInstructions().indexOf(inst), div);
           curBlock.getInstructions().add(curBlock.getInstructions().indexOf(div) + 1, mul);
           curBlock.getInstructions().add(curBlock.getInstructions().indexOf(mul) + 1, sub);
           inst.replaceByNewValue(sub);
           curBlock.getInstructions().remove(inst);
           inst.removeOperands();
       }
   }
   ```

3. 对计算语句`BinaryInst`，分别讨论两个操作数中常数的数量，进行对应的优化

   - 两个操作数均为常数，则可以立即计算结果并代替原指令
   - 其中一个操作数为常数
     - a + 0 = 0 + a = a
     - a - 0 = a
     - a * 0 = 0 * a = 0
     - a * 1 = 1 * a = a
     - 0 / a = 0
     - a / 1 = 1
     - o % a = 0
     - a % 1 = a % (-1) = 0
   - 两个操作数均非常数
     - (a - b) + b = b + (a - b) = a
     - (a + b) + (a - b) = 2a
     - a - a = 0
     - (a + b) - b = a, (a + b) - a = b
     - a - (a - b) = b
     - a / a = 1
     - a % a = 0

4. 完成后对phi节点进行优化：

   - 清理Phi指令中来自已删除基本块的操作数和对应的基本块；
   - 如果Phi指令的所有操作数相同，或者Phi指令没有用户，则将Phi指令替换为其中一个操作数，简化Phi指令；
   - 移除Phi指令中来自已删除基本块的操作数和对应的基本块

### 跳转优化

与常量折叠类似，对于一些`icmp`指令，也可提前计算出结果，如`%cmp1 = icmp eq i32 5, 5`可被替换为`%cmp1 = 1`。

```java
private static void icmpOptimize(BinaryInst binaryInst) {
    Value value1 = binaryInst.getOperand1();
    Value value2 = binaryInst.getOperand2();
    if (value1 instanceof ConstInt constInt1 && value2 instanceof ConstInt constInt2) {
        OperatorType op = binaryInst.getOpType();
        int cons1 = constInt1.getIntValue();
        int cons2 = constInt2.getIntValue();
        int value = switch (op) {
            case ICMP_EQ -> cons1 == cons2 ? 1 : 0;
            case ICMP_NE -> cons1 != cons2 ? 1 : 0;
            case ICMP_SGE -> cons1 >= cons2 ? 1 : 0;
            case ICMP_SGT -> cons1 > cons2 ? 1 : 0;
            case ICMP_SLE -> cons1 <= cons2 ? 1 : 0;
            case ICMP_SLT -> cons1 < cons2 ? 1 : 0;
            default -> 0;
        };
        ConstInt constInt = new ConstInt(IntegerType.i1, value);
        BasicBlock curBlock = binaryInst.getBasicBlock();
        curBlock.getInstructions().remove(binaryInst);
        binaryInst.replaceByNewValue(constInt);
        binaryInst.removeOperands();
    }
}
```

此时一些`br`的跳转方向已经确定，此时可以通过将有条件br改写成无条件br，例如`br i1 1, label %true, label %false`可被替换为`br label %true`。

跳转优化不仅能减少代码体积，同时通过删除无用代码与修改CFG，暴露潜在的优化机会。

```java
private static void brOptimize(BrInst brInst) {
    Value value = brInst.getCondition();
    BasicBlock curBlock = brInst.getBasicBlock();
    if (value instanceof ConstInt constInt) {
        BrInst noCondBr;
        BasicBlock targetBlock;
        if (constInt.getIntValue() == 0) {
            targetBlock = brInst.getFalseBlock();
            curBlock.deleteForPhi(brInst.getTrueBlock());
        } else {
            targetBlock = brInst.getTrueBlock();
            curBlock.deleteForPhi(brInst.getFalseBlock());
        }
        noCondBr = new BrInst(targetBlock);
        curBlock.getInstructions().set(curBlock.getInstructions().indexOf(brInst), noCondBr);
        brInst.removeOperands();
    }
}
```

最后同样对phi指令进行处理，同时删除掉不可达的基本块。

### 全局变量访存优化

对于全局变量可通过跟踪load和store进行优化。

- store指令：
  - 跟踪对全局变量的存储操作，记录最新的存储值。
  - 如果全局变量的存储值已经被记录且没有被修改，可以移除冗余的store指令。

- load指令：
  - 如果加载操作指向的全局变量已经有最新的存储值，可以将load指令替换为存储的常量值，消除不必要的内存读取。

- 处理函数调用：
  - 函数调用可能会修改全局变量的状态，因此在遇到call指令时，需要清除当前的存储映射，确保后续优化的正确性。
  - 在函数调用之前，重新插入所有记录的store指令，以维护全局变量的状态一致性。

```java
private static void optimizeGlobalVar(BasicBlock basicBlock) {
    HashMap<GlobalVar, Value> gvMap = new HashMap<>();
    HashMap<GlobalVar, Value> writeMap = new HashMap<>();
    ArrayList<Instruction> instructions = new ArrayList<>(basicBlock.getInstructions());
    // 如果是全局数组，那么getPointer得到的应该是gepInst
    // 因此以下的操作针对的是全局变量，而非全局数组
    for (Instruction instruction : instructions) {
        if (instruction instanceof StoreInst storeInst) {
            if (!(storeInst.getPointer() instanceof GlobalVar globalVar)) {
                continue;
            }
            gvMap.put(globalVar, storeInst.getStoredValue());
            writeMap.put(globalVar, storeInst.getStoredValue());
            storeInst.removeOperands();
            basicBlock.getInstructions().remove(instruction);
        } else if (instruction instanceof LoadInst loadInst) {
            if (!(loadInst.getPointer() instanceof GlobalVar globalVar)) {
                continue;
            }
            if (gvMap.containsKey(globalVar)) {
                loadInst.replaceByNewValue(gvMap.get(globalVar));
                loadInst.removeOperands();
                basicBlock.getInstructions().remove(instruction);
            } else {
                gvMap.put(globalVar, loadInst);
            }
        } else if (instruction instanceof CallInst callInst) {
            gvMap.clear();
            for (Map.Entry<GlobalVar, Value> entry : writeMap.entrySet()) {
                StoreInst storeInst = new StoreInst(entry.getKey(), entry.getValue());
                storeInst.setBasicBlock(basicBlock);
                basicBlock.getInstructions().add(basicBlock.getInstructions().indexOf(callInst), storeInst);
            }
            writeMap.clear();
        }
    }
    for (Map.Entry<GlobalVar, Value> entry : writeMap.entrySet()) {
        StoreInst storeInst = new StoreInst(entry.getKey(), entry.getValue());
        storeInst.setBasicBlock(basicBlock);
        basicBlock.getInstructions().add(basicBlock.getInstructions().size() - 1, storeInst);
    }
}
```

### 基本块合并与基本块重排

合并基本块并对基本块进行排序，可以降低跳转指令的执行次数。

如果`block`有且仅有一个后继基本块`child`，并且`child`的前驱基本块数量也是1（即只有`block`一个前驱），且未被删除，则可以尝试合并。合并之后需要对涉及到的br语句与phi结点进行修改。

```java
private static boolean merge(Function function) {
    boolean merged = false;
    ArrayList<BasicBlock> blocks = new ArrayList<>(function.getBasicBlocks());

    // 使用迭代器安全地在遍历时移除块
    Iterator<BasicBlock> it = blocks.iterator();
    while (it.hasNext()) {
        BasicBlock block = it.next();
        if (block.isDeleted()) {
            continue;
        }
        if (block.getNextBlocks().size() == 1) {
            BasicBlock child = block.getNextBlocks().get(0);
            if (child.getPrevBlocks().size() == 1 && !child.isDeleted()) {
                // 合并块和子块
                performMerge(block, child);
                merged = true;
            }
        }
    }

    // 如果进行了合并，更新函数的基本块列表
    if (merged) {
        // 过滤掉已删除的块
        ArrayList<BasicBlock> updatedBlocks = new ArrayList<>();
        for (BasicBlock block : blocks) {
            if (!block.isDeleted()) {
                updatedBlocks.add(block);
            }
        }
        function.setBasicBlocks(updatedBlocks);
    }

    return merged;
}

private static void performMerge(BasicBlock parent, BasicBlock child) {
    // 从父块中移除跳转指令
    Instruction jumpInstr = parent.getLastInstruction();
    jumpInstr.removeOperands();
    parent.getInstructions().remove(jumpInstr);

    // 将子块中的所有指令移动到父块
    Iterator<Instruction> it = child.getInstructions().iterator();
    while (it.hasNext()) {
        Instruction instr = it.next();
        if (instr instanceof PhiInst phiInst) {
            // 更新 phi 指令以使用来自父块的操作数
            int index = phiInst.getBlocks().indexOf(parent);
            if (index != -1) {
                Value newValue = phiInst.getOperands().get(index);
                phiInst.replaceByNewValue(newValue);
            }
            phiInst.removeOperands();
        } else {
            parent.getInstructions().add(instr);
            instr.setBasicBlock(parent);
        }
        it.remove();
    }

    // 将子块的引用重定向到父块，并标记子块为已删除
    child.replaceByNewValue(parent);
    child.setDeleted(true);
}
```

对已有的基本块，可以采用dfs的方法进行排序，使得控制流路径上的基本块尽可能连续排列，提升指令缓存的命中率，提高执行效率。

```java
private static ArrayList<BasicBlock> reorderBasicBlocksDFS(Function function) {
    List<BasicBlock> blocks = function.getBasicBlocks();
    ArrayList<BasicBlock> orderedBlocks = new ArrayList<>();
    Set<BasicBlock> visited = new HashSet<>();
    Deque<BasicBlock> stack = new ArrayDeque<>();

    if (!blocks.isEmpty()) {
        stack.push(blocks.get(0));
    }

    while (!stack.isEmpty()) {
        BasicBlock current = stack.pop();
        if (!visited.contains(current)) {
            visited.add(current);
            orderedBlocks.add(current);
            // 逆序压栈以保持顺序
            List<BasicBlock> successors = getSuccessors(current);
            Collections.reverse(successors);
            for (BasicBlock succ : successors) {
                if (!visited.contains(succ)) {
                    stack.push(succ);
                }
            }
        }
    }

    // 将未在DFS中访问到的块追加到末尾
    for (BasicBlock block : blocks) {
        if (!visited.contains(block)) {
            orderedBlocks.add(block);
        }
    }

    return orderedBlocks;
}
```

### 输出优化

对于连续输出的常数/常字符串，可以通过连续拼接整合输出。

```java
private static void optimize(BasicBlock block) {
    boolean changed = true;
    while (changed) {
        changed = false;
        ArrayList<Instruction> instructions = new ArrayList<>(block.getInstructions());
        for (int i = 0; i < instructions.size(); i++) {
            Instruction instruction = instructions.get(i);
            if (!(instruction instanceof OutputInst outputInst)) {
                continue;
            }
            if (!outputInst.constContent()) {
                continue;
            }
            ArrayList<Instruction> buffer = new ArrayList<>();
            buffer.add((Instruction) outputInst);
            int j = i + 1;
            // 连续获取输出语句
            for (; j < instructions.size(); j++) {
                if (instructions.get(j) instanceof OutputInst temp && temp.constContent()) {
                    buffer.add((Instruction) temp);
                } else {
                    break;
                }
            }
            if (buffer.size() < 2) {
                continue;
            }
            StringBuilder sb = new StringBuilder();
            for (Instruction output : buffer) {
                sb.append(((OutputInst) output).getConstContent());
            }
            String output = sb.toString();
            output = output.replace("\\0A", "\n");
            ConstString constString = new ConstString(IRData.getConstStringName(), output);
            PutstrInst putstr = new PutstrInst(constString);
            block.getInstructions().set(i, putstr);
            block.getInstructions().removeAll(buffer);
            changed = true;
            break;
        }
    }
}
```

## 后端优化

### 消除phi结点

按照教程的算法可以对插入的phi结点进行处理，转化为一组move语句。

检测移动指令之间的依赖关系，避免因覆盖导致的错误，需要引入临时变量以安全地重新排序移动指令，确保原始值在过程中被正确保留。如果前驱块有多个后继块，创建一个新的基本块来保存移动指令，并在新块中添加跳转指令到当前块。这避免了干扰其他后继块的控制流。

### 寄存器分配

寄存器分配采用启发式图着色算法。

1. 计算`def`和`use`集合，通过$in[B] = use[B] \cup (out[B] - def[B])，  out[B] = \cup_{B的后继块P}in[P]$计算`in`和`out`集合

2. 构建干涉图，遍历每个基本块，初始化活跃变量集合为该块的OUT集合。

   逆序遍历指令，更新活跃变量集合：

   - 如果指令定义了一个变量，则从活跃集合中移除该变量，并与当前活跃变量建立干涉关系。
   - 将指令的操作数添加到活跃变量集合。

3. 按照教程的算法实现着色和溢出。

在目标代码生成截断已经为变量在栈上预留了空间，对于溢出的变量，将值存在栈上对应位置即可。

### 计算强度削弱

采用教程提到的方法对乘除等计算进行额外处理，从而降低周期数。

对于`变量 * 常数`类型的乘法运算，可以根据常数的值分类讨论：

- 常数是0、1、-1，比较简单
- 常数是负数，将其转化为正数，最后使用取反
- 常数（绝对值）大小在2-9之间，通过已经构造好的方法进行翻译
- 常数（绝对值）的二进制表示中1的个数不多于2，可以通过移位的组合来实现
- 除此之外的情况直接使用乘法指令

```java
private void makeVarMulConst(Register varReg, int constInt, Register targetReg) {
    if (constInt == 0) {
        new LiAsm(targetReg, 0);
        return;
    }
    if (constInt == 1) {
        new MoveAsm(targetReg, varReg);
        return;
    }
    if (constInt == -1) {
        new CalcAsm(targetReg, AsmOp.SUBU, Register.ZERO, varReg);
        return;
    }
    boolean isNegative = constInt < 0;
    int absConstInt = Math.abs(constInt);
    switch (absConstInt) {
        case 2:
            new CalcAsm(targetReg, AsmOp.ADDU, varReg, varReg);
            break;
        case 3:
            new CalcAsm(Register.V0, AsmOp.ADDU, varReg, varReg);
            new CalcAsm(targetReg, AsmOp.ADDU, Register.V0, varReg);
            break;
        case 4:
            new CalcAsm(targetReg, AsmOp.SLL, varReg, 2);
            break;
        case 5:
            new CalcAsm(Register.V0, AsmOp.SLL, varReg, 2);
            new CalcAsm(targetReg, AsmOp.ADDU, Register.V0, varReg);
            break;
        case 6:
            new CalcAsm(Register.V0, AsmOp.SLL, varReg, 2);
            new CalcAsm(Register.V1, AsmOp.ADDU, varReg, varReg);
            new CalcAsm(targetReg, AsmOp.ADDU, Register.V0, Register.V1);
            break;
        case 7:
            new CalcAsm(Register.V0, AsmOp.SLL, varReg, 3);
            new CalcAsm(targetReg, AsmOp.SUBU, Register.V0, varReg);
            break;
        case 8:
            new CalcAsm(targetReg, AsmOp.SLL, varReg, 3);
            break;
        case 9:
            new CalcAsm(Register.V0, AsmOp.SLL, varReg, 3);
            new CalcAsm(targetReg, AsmOp.ADDU, Register.V0, varReg);
            break;
        default:
            int bitCnt = Integer.bitCount(absConstInt);
            if (bitCnt <= 2) {
                // 使用原有的移位和加法逻辑
                int[] shifts = new int[2];
                int index = 0;
                for (int i = 0; i < 32; i++) {
                    if ((absConstInt & (1 << i)) != 0) {
                        shifts[index++] = i;
                        if (index == 2) break;
                    }
                }

                if (bitCnt == 1) {
                    new CalcAsm(targetReg, AsmOp.SLL, varReg, shifts[0]);
                } else {
                    new CalcAsm(Register.V0, AsmOp.SLL, varReg, shifts[0]);
                    new CalcAsm(Register.V1, AsmOp.SLL, varReg, shifts[1]);
                    new CalcAsm(targetReg, AsmOp.ADDU, Register.V0, Register.V1);
                }
            } else {
                // 对于其他情况，使用乘法
                new LiAsm(Register.V0, absConstInt);
                new CalcAsm(targetReg, AsmOp.MUL, varReg, Register.V0);
            }
    }
    if (isNegative) {
        new CalcAsm(targetReg, AsmOp.SUBU, Register.ZERO, targetReg);
    }
}
```

对于除法，可以参考论文中的实现：

![图片#100% #auto](https://drinkwater-1325041233.cos.ap-guangzhou.myqcloud.com/imgs/cguserImages)

代码实现如下：

```java
public class OptimizedDivision {
    private static long calculateMagicNumber(int divisor) {
        long nc = ((1L << 31) - ((1L << 31) % divisor) - 1) / divisor;
        long t = 32;
        while ((1L << t) <= nc * (divisor - (1L << t) % divisor)) {
            t++;
        }
        return ((1L << t) + divisor - (1L << t) % divisor) / divisor;
    }

    public static void makeVarDivConst(Register varReg, int constInt, Register targetReg) {
        int abs = Math.abs(constInt);
        if (abs == 1) {
            if (constInt < 0) {
                new CalcAsm(targetReg, AsmOp.SUBU, Register.ZERO, varReg);
            } else {
                new MoveAsm(targetReg, varReg);
            }
            return;
        }

        if ((abs & (abs - 1)) == 0) {
            // Power of 2 case
            int shift = 31 - Integer.numberOfLeadingZeros(abs);
            Register dividend = getDividend(varReg, abs);
            new CalcAsm(targetReg, AsmOp.SRA, dividend, shift);
        } else if (abs < 32) {
            // Use pre-calculated magic numbers for small divisors
            long m = calculateMagicNumber(abs);
            int n = (int) ((m << 32) >>> 32);
            int shift = (int) (m >>> 32);
            new LiAsm(Register.V0, n);
            new MulDivAsm(varReg, AsmOp.MULT, Register.V0);
            new MDRegAsm(AsmOp.MFHI, Register.V1);
            new CalcAsm(Register.V0, AsmOp.SRA, Register.V1, shift);
            new CalcAsm(Register.A0, AsmOp.SRL, varReg, 31);
            new CalcAsm(targetReg, AsmOp.ADDU, Register.V0, Register.A0);
        } else {
            // Original logic for larger divisors
            long t = 32;
            long nc = ((long) 1 << 31) - (((long) 1 << 31) % abs) - 1;
            while (((long) 1 << t) <= nc * (abs - ((long) 1 << t) % abs)) {
                t++;
            }
            long m = ((((long) 1 << t) + (long) abs - ((long) 1 << t) % abs) / (long) abs);
            int n = (int) ((m << 32) >>> 32);
            int shift = (int) (t - 32);
            new LiAsm(Register.V0, n);
            if (m >= 0x80000000L) {
                new MDRegAsm(AsmOp.MTHI, varReg);
                new MulDivAsm(varReg, AsmOp.MADD, Register.V0);
            } else {
                new MulDivAsm(varReg, AsmOp.MULT, Register.V0);
            }
            new MDRegAsm(AsmOp.MFHI, Register.V1);
            new CalcAsm(Register.V0, AsmOp.SRA, Register.V1, shift);
            new CalcAsm(Register.A0, AsmOp.SRL, varReg, 31);
            new CalcAsm(targetReg, AsmOp.ADDU, Register.V0, Register.A0);
        }
        if (constInt < 0) {
            new CalcAsm(targetReg, AsmOp.SUBU, Register.ZERO, targetReg);
        }
    }

    private static Register getDividend(Register oldDividend, int abs) {
        int l = 31 - Integer.numberOfLeadingZeros(abs);
        new CalcAsm(Register.V0, AsmOp.SRA, oldDividend, 31);
        if (l > 0) {
            new CalcAsm(Register.V0, AsmOp.SRL, Register.V0, 32 - l);
        }
        new CalcAsm(Register.V1, AsmOp.ADDU, oldDividend, Register.V0);
        return Register.V1;
    }
}
```

### 窥孔优化

针对一小段mips代码也可进行优化，亦能取得不错的效果。

`PlatoCompiler`设计的窥孔优化种类如下：

- 相邻的jump和label

  ```assembly
  j label1 # 可删去
  label1:
  ```

- 加法转换：`addiu $t1, $t2, 0`可变为`move $t1, $t2`

- 删除多余的move

  ```assembly
  move $t1, $t1 # 可删去
  
  move $t1, $t2 # 可删去
  move $t1, $t3 
  
  move $t1, $t2
  move $t2, $t1 # 可删去
  ```

- 访存优化

  ```assembly
  sw $t1, 0($t0)
  lw $t2, 0($t0)
  
  move $t2, $t1 # 与以上代码等价
  ```

- 条件跳转优化

  ```assembly
  beq $t4, $zero, label1
  j label2
  label1:
  
  # 可转化为
  bne $t4, $zero, label2
  label1:
  ```

- 加强无条件跳转优化：经过以上优化之后可能有空块，此时删去无条件跳转指令，pc也能自然移动到目标标签

  ```assembly
  j main_b7 # 可删去
  
  main_b4:
  # move %37 -> %3
  # br label %7
  
  main_b7:
  ```

- 立即数优化：可能用于连续输出

  ```assembly
  li $t1, 5 # 可删去
  li $t1, 10
  move $t2, $t1
  ```

  

# 编译实验设计文档

## 参考编译器

### 总体结构

选择Pascal-S编译器进行参考。Pascal-S Compiler是一种简化的Pascal编译器，按照功能可以分为以下模块：

- **词法分析**：从源代码中读取字符，并将其分解为单词符号（tokens）。
- **语法分析**：基于递归下降的方法，验证代码的结构是否符合Pascal语言的语法规则。
- **语义分析**：检查代码中的变量、类型、表达式等是否具有正确的含义。
- **代码生成**：生成对应的P-code指令序列。
- **符号表管理**：记录程序中标识符（如变量、常量、函数等）的信息。
- **异常处理**：在各个阶段提供异常检测和处理，确保用户得到有用的异常信息。

通过以上过程，编译器将源程序解析为中间代码形式（P-code）。

### 实用工具

用于处理异常、调试信息和设置符号表等内容。它们提高了编译器的可扩展性和易维护性。

- **errormsg**：输出异常信息，将编译过程中捕获的异常逐条列出，并提供相应的异常说明。
- **endskip**：出现异常后，如果跳过了部分代码，用下划线标记被跳过的内容以便定位问题。
- **error(n: integer)**：接收异常编号`n`，打印出错的具体位置和异常编号。
- **fatal(n: integer)**：当遇到致命异常（如符号表或数组超出限制）时，打印表格溢出等相关信息，终止编译过程。
- **options**：处理编译时的选项设置，如是否开启符号表输出、调试模式等。
- **switch(var b: boolean)**：处理编译时的可选项。
- **setup**：初始化编译器的各种表格和数据结构，为编译过程提供基础信息和环境。
- **enterids**：将Pascal语言的标准类型、过程和函数名（如`integer`、`boolean`、`write`等）注册到符号表中，以供后续阶段使用。

### 词法分析

负责从源代码中逐字符读取内容，并生成对应的单词符号（tokens），供语法分析阶段使用。

- **nextch**：读取下一个字符，并处理行尾字符。如果读取到文件末尾，则报告错误。
- **insymbol**：解析下一个单词符号，处理关键字、标识符、常量、操作符及注释行等。
- **readscale**：当解析实数时，负责处理其指数部分。
- **adjustscale**：根据实数的小数位和指数部分，计算出实际的数值。

### 语法分析

语法分析器的主要任务是验证源代码的语法结构，确保它符合Pascal语言的语法规则。在Pascal-S编译器中，语法分析采用递归下降方法，通过逐层递归解析程序的各个部分。每个结构（如表达式、语句、过程）都有对应的分析函数，逐一检查其合法性，并生成中间代码。

1. **block(fsys: symset; isfun: boolean; level: integer)**
   用于分析分程序块（如主程序、过程或函数），负责处理程序体、变量声明、类型声明、常量声明和嵌套的过程或函数定义。

   参数`fsys`用于检查符号是否合法，`isfun`标记当前是否为函数，`level`表示当前的嵌套层次。

   - **parameterlist**
     处理形式参数表。用于过程或函数的定义中，分析形式参数的声明部分，检查参数的类型和标识符是否合法。

   - **skip(fsys；n)**

     跳过错误部分的代码，直到找到属于`fsys`集合的符号，主要用于错误恢复。

   - **test(s1, s2: symset; n: integer)**
     检查当前符号是否属于集合`s1`。如果不在集合中，则跳过，继续寻找`fsys`中的合法符号。

   - **testsemicolon**
     检查当前符号是否为分号，若不是，则输出错误信息并进行容错处理。

2. **typ(fsys: symset; var tp: types; var rf, sz: integer)**
   解析并处理类型定义。检查类型声明部分，如标量类型、数组类型和记录类型，返回其大小和引用。

   - **arraytyp(var aref, arsz: integer)**
     处理数组类型的声明，解析数组的上下界和元素类型，并记录数组的大小。
   - **constant(fsys: symset; var c: conrec)**
     处理常量定义。该函数解析常量表达式，识别整数、实数或字符常量，返回常量的类型和数值。

3. **expression(fsys: symset; var x: item)**
   递归解析表达式中的操作数和运算符。

   - **selector(fsys: symset; var v: item)**
     处理复杂的表达式元素，如数组下标、记录成员引用等。
   - **simpleexpression(fsys: symset; var x: item)**
     处理简单的表达式，如加法、减法和逻辑运算，返回计算结果的类型。
   - **term(fsys: symset; var x: item)**
     处理表达式中的项。项通常是由乘法、除法等操作符连接的基本元素。
   - **factor(fsys: symset; var x: item)**
     处理因子，因子是表达式中的最小单元，通常是常量、变量或函数调用。

4. **call(fsys: symset; i: integer)**
   处理过程或函数调用。

5. **statement(fsys: symset)**
   解析各种类型的语句，如赋值语句、控制语句（`if`、`while`、`for`等）。

   - **ifstatement**：处理`if`语句，包括`then`和`else`分支。
   - **casestatement**：处理`case`语句，支持多分支选择结构。
   - **repeatstatement**：处理`repeat...until`语句。
   - **whilestatement**：处理`while`循环结构。
   - **forstatement**：处理`for`循环结构。
   - **assignment(lv, ad: integer)**：处理赋值语句，生成赋值操作的中间代码。
   - **compoundstatement**：处理复合语句，支持多个语句块组合在一起执行。
   - **caselabel**：处理`case`语句中的标号，将标号对应的目标代码地址填入case表。
   - **onecase**：处理`case`语句中的单个分支。
   - **standproc(n: integer)**：处理标准过程调用，如`read`、`write`等输入输出过程。

### 语义分析

确保程序中的操作符和操作数类型匹配，变量在使用前已声明，过程和函数的调用与定义一致等。

1. **变量与常量声明的语义检查**

   - **entervariable**：将变量注册到符号表中，并检查变量是否已经声明或是否与其他符号冲突。通过符号表的结构，确保每个变量都有合法的声明。
   - **constdec**：处理常量的声明，检查常量的类型是否匹配。例如，整数常量不能赋值为实数，字符常量必须是单个字符等。

2. **类型检查**

   - **typ(fsys: symset; var tp: types; var rf, sz: integer)**：该函数不仅在语法上解析类型，还负责检查每个类型定义的合法性。例如，数组的上下界必须是整数，记录类型中的每个字段必须有合法的类型。
   - **resulttype(a, b: types): types**：该函数用于检查表达式中两个操作数的类型是否兼容。如果两个操作数的类型不匹配，会生成类型错误。例如，不能将整数和布尔值进行加法运算。

3. **过程与函数调用的语义检查**

   - **call(fsys: symset; i: integer)**：在解析过程或函数调用时，编译器会检查实际参数和形式参数的类型是否一致。形参和实参类型不匹配时，会报告错误。

4. **表达式与操作符的类型检查**

   - **expression(fsys: symset; var x: item)**：检查操作符和操作数的类型是否匹配。
   - **term(fsys: symset; var x: item)**：检查乘法、除法等运算的左右操作数是否都是数值类型。
   - **factor(fsys: symset; var x: item)**：解析因子时，确保因子是常量、变量或函数调用的类型。

5. **控制结构的语义检查**

   - **ifstatement**：检查`if`语句的条件部分是否为布尔类型。
   - **whilestatement**、**repeatstatement**、**forstatement**：与`ifstatement`类似也会进行相应的语义检查。

6. **符号表管理与作用域检查**

   每进入一个新的作用域，编译器会将当前符号表的上下文存储在`display`数组中，确保作用域的正确性。

   - **loc(id: alfa): integer**：用于在符号表中查找标识符`id`，确保符号已经声明，并返回其在符号表中的位置。如果未找到符号，将报告错误。

### 代码生成

生成中间代码（P-code），供虚拟机解释执行。

- **emit(fct: integer)**：生成没有操作数的P-code指令。
- **emit1(fct: integer, b: integer)**：生成带一个操作数的P-code指令。
- **emit2(fct: integer, a: integer, b: integer)**：生成带两个操作数的P-code指令。
- **interpret**：P-code解释器，负责解释和执行生成的P-code。
- **dump**：在运行时输出栈内容、显示符号表、显示代码执行的当前状态，帮助调试。

### 符号表管理

符号表用于记录程序中定义的变量、常量、类型、过程和函数的信息。

- **enter(x0: alfa, x1: objecttyp, x2: types, x3: integer)**：将一个标识符注册到符号表中。
- **enterarray(tp: types, l, h: integer)**：注册数组类型的信息。
- **enterblock**：记录一个新的过程或函数块。
- **enterreal(x: real)**：将实数常量注册到符号表中。
- **entervariable**：将变量名注册到符号表中。
- **constdec**：处理常量定义，并将其信息注册到符号表。
- **typedeclaration**：处理类型定义。
- **variabledeclaration**：处理变量定义。
- **procdeclaration**：处理过程和函数定义，并递归解析其内部代码块。
- **printtables**：打印符号表、实数常量表、过程和函数表等内容。

### 文件组织

Pascal-S Compiler的所有功能都在一个文件内完成，整体结构较为耦合。每个功能模块以过程形式实现，彼此之间依赖较大，函数调用链较长，模块化程度较低。

## 编译实验设计

### 总体结构

根据Pascal-S编译器和理论部分的相关知识，可以将编译器分为前端，中端，后端三个部分。

* 前端：词法分析、语法分析
* 中端：语义分析、中间代码生成、中端优化
* 后端：目标代码生成、后端优化

在进行词法分析、语法分析、语义分析的同时建立符号表并进行异常处理。

### 接口设计

- 词法分析接受字符串形式的源程序，返回一系列被分割好的词法单元`token`
- 语法分析接受一个token列表，返回一棵根节点名为`CompUnit`的语法树
- 中端接受语法树，返回一个`LLVM IR`中的`Module`结点
- 后端接受`Module`结点，返回一个由`MIPS`指令组成的列表

每个类功能相互独立，方便进行单元测试。在编译器类`Compiler`中，通过合适的接口设计，可以降低类之间的耦合度，同时使得代码简洁。

```java
public class Compiler {
    // 文件输入/输出路径
    private static final String inputFile = "testfile.txt";
    private static final String lexerOutput = "lexer.txt";
    private static final String parserOutput = "parser.txt";
    private static final String errorOutput = "error.txt";
    private static final String symbolOutput = "symbol.txt";
    private static final String llvmOutput = "llvm_ir.txt";
    private static final String irOutput = "ir.txt";
    private static final String mipsOutput = "mips.txt";
    // 生成中间代码/目标代码的开关
    private static final boolean toLLVM = true;
    private static final boolean toMips = true;
	// 优化开关
    private static final boolean optimize = false;

    public static void main(String[] args) throws Exception {
        String inputString = Files.readString(Paths.get(inputFile));
        // 词法分析部分
        // tokens是已划分好的源程序的词法单元
        Lexer lexer = new Lexer(inputString);
        ArrayList<Token> tokens = lexer.tokenize();
        Printer.printTokens(tokens, lexerOutput);
        // 语法分析部分
        // compUnit是源程序所生成的语法树的根节点
        Parser parser = new Parser(tokens);
        CompUnit compUnit = parser.parse();
        Printer.printCompUnit(compUnit, parserOutput);
        // 语义分析，建立符号表
        Visitor visitor = new Visitor(compUnit);
        visitor.visit();
        // 异常处理：如果源代码在上述三部分存在异常，不构建中间/目标代码
        Printer.printErrors(ErrorHandler.getInstance().getErrors(), errorOutput);
        if (!ErrorHandler.getInstance().getErrors().isEmpty()) {
            return;
        }
        // 异常处理：如果不存在异常，打印符号表
        Printer.printSymbols(symbolOutput);
        if (toLLVM) {
            // 生成未优化中间代码
            IRBuilder irBuilder = new IRBuilder(compUnit);
            irBuilder.build();
            Printer.printIr(Module.getInstance(), llvmOutput);
            if (optimize) {
                // 中间代码优化
                Optimizer optimizer = new Optimizer(Module.getInstance());
                optimizer.optimize();
                Module.getInstance().updateId();
                Printer.printIr(Module.getInstance(), irOutput);
            }
            if (toMips) {
                // 目标代码生成
                MipsBuilder mipsBuilder = new MipsBuilder(Module.getInstance(), optimize);
                mipsBuilder.build(optimize);
                Printer.printMips(MipsFile.getInstance(), mipsOutput);
            }
        }
    }
}
```

### 文件组织

```
PlatoCompiler
└─src
    ├─backend               # 后端生成目标代码
    │  ├─enums               # 枚举类，包括寄存器和MIPS指令类型
    │  ├─global               #  .data段的内容
    │  ├─text                 #  .text段的内容，包括各种指令的
    │  └─utils               #  后端优化
    ├─error                 # 异常处理
    ├─frontend
    │  ├─syntax             #  语法树结点的数据结构：分类为表达式、函数、语句、变量
    │  │  ├─expression
    │  │  ├─function
    │  │  ├─statement
    │  │  └─variable
    │  └─token              #  词法单元的数据结构
    ├─middle              #  中端进行语义分析并生成中间代码
    │  ├─symbol             # 符号表数据结构
    │  └─component         # 中端的数据结构
    │      ├─instruction   # LLVM IR中的指令对象
    │      │  └─io
    │      ├─model         # LLVM IR中的User Use Value模型
    │      └─type          #  LLVM中的储存数据类型的数据结构
    ├─optimize            #  中端优化
    └─tools              #  一些实用工具，如Printer等
```

## 词法分析

### 编码前设计

词法分析的主要任务是从源程序中识别出词法单元，记录类别和值（以字符串类型保存）。

在`PlatoCompiler`中，词法分析位于`frontend`包中，包括词法分析器`Lexer`和`token`包（包括词法单元类`Token`和词法单元类型枚举类`TokenType`）。

#### 输入/输出处理

编译器的第一步任务是将源程序文件以字符串形式读入。

```java
// Compiler.java
public class Compiler {
    // 其他部分
    public static void main(String[] args) throws Exception {
        String inputString = Files.readString(Paths.get(inputFile));
        // 其他部分
    }
}
```

对于作业中每一个要求的输出，我将方法统一包装在打印工具类`Printer`中，实现处理逻辑与输出逻辑的分离。

#### 词法单元

词法单元类`Token`存储了类型，值，行号信息。行号主要在异常处理输出的时候被使用。

```java
public class Token {
    private final TokenType tokenType;
    private final String content;
    private final int line;
}
```

使用枚举类`TokenType`标记token的种类，与使用int类型变量标记种类可读性更强。

#### 词法分析器

词法分析器接受源程序字符串，返回一个分割好的token列表，以ArrayList格式存储。

`Lexer`通过`tokenize`方法与`Compiler`进行交互。

```java
// Lexer.java
public ArrayList<Token> tokenize() {
    ArrayList<Token> tokens = new ArrayList<>();
    while (hasNext()) {
        tokens.add(new Token(type, curToken.toString(), line));
    }
    return tokens;
}
```

`Lexer`类中最关键的是`hasNext`方法，根据词法规则构建状态图，通过指针在源程序字符串上的位置判断接下来的字符是否能组成合法token，执行逻辑如下：

- 首先跳过空白成分，指针指向第一个非空字符。如果读取到`\n`，需要将当前行号+1。

  ```java
  private void skip() {
      while (pos < inputString.length() && isBlank(inputString.charAt(pos))) {
          pos++;
      }
  }
  
  private boolean isBlank(char c) {
      if (c == '\n') {
          line++;
          return true;
      } else {
          return c == ' ' || c == '\t' || c == '\r';
      }
  }
  ```

- 判断当前字符的类型进行解析。例如若当前字符为`+`，则将其解析为类型为`PLUS`的token。

  - 如果当前字符为数字，需要不断读入后面的数字

  - 将标识符和保留字统一处理

    - 如果当前字符为下划线或字母，不断读入后面的字符，拼接成一个字符串

    - 通过判断字符串是否在保留字表中来判断其类型是保留字还是标识符

    - 代码实现为：

      ```java
      if (isIdHead(c)) {
          while (isIdHead(inputString.charAt(pos)) || Character.isDigit(inputString.charAt(pos))) {
              addChar();
          }
          // 通过判断字符串是否在保留字表中来判断其类型
          type = reservedMap.getOrDefault(curToken.toString(), TokenType.IDENFR);
      }
      ```

  - 如果当前字符为大于小于等于号，需要进一步判断

    ```java
    private void getCmpOrAgn(char ch) {
        addChar();
        if (inputString.charAt(pos) == '=') {
            addChar();
            switch (ch) {
                case '<' -> type = TokenType.LEQ;
                case '>' -> type = TokenType.GEQ;
                case '=' -> type = TokenType.EQL;
                default -> throw new RuntimeException("Unexpected character combination " +
                        "at line " + line);
            }
        } else {
            switch (ch) {
                case '<' -> type = TokenType.LSS;
                case '>' -> type = TokenType.GRE;
                case '=' -> type = TokenType.ASSIGN;
                default -> throw new RuntimeException("Unexpected character " +
                        "at line " + line);
            }
        }
    }
    ```

    同理，读取到感叹号时，也需要判断其是`!`还是`!=`。

  - 如果当前符号为除号，需要判断其是除法、单行注释还是多行注释

    ```java
    private boolean getDivOrCmt() {
        if (inputString.charAt(pos + 1) == '/') {
            // 单行注释，跳过之后的内容
            while (pos < inputString.length() && inputString.charAt(pos) != '\n') {
                pos++;
            }
            return hasNext();
        } else if (inputString.charAt(pos + 1) == '*') {
            // 多行注释
            pos += 2;
            int commentStartLine = line;
            int commentLevel = 1;
            while (pos + 1 < inputString.length() && commentLevel > 0) {
                if (inputString.charAt(pos) == '*' && inputString.charAt(pos + 1) == '/') {
                    commentLevel--;
                    pos += 2;
                } else if (inputString.charAt(pos) == '/' && inputString.charAt(pos + 1) == '*') {
                    commentLevel++;
                    pos += 2;
                } else {
                    if (inputString.charAt(pos) == '\n') {
                        line++;
                    }
                    pos++;
                }
            }
            if (commentLevel > 0) {
                throw new RuntimeException("Unterminated comment starting at line "
                        + commentStartLine);
            }
            return hasNext();
        }
        // 只是单纯的除号
        addChar();
        type = TokenType.DIV;
        return true;
    }
    ```

#### 异常处理

词法分析阶段可能出现的异常为a类异常，即出现了 '&' 和 '|' 这两个符号。此时，应该将 其当做 '&&' 与 '||' 进行处理，但是在 记录单词名称的时候仍记录 '&' 和 '|'， 报错行号为 '&' 或 '|' 所在的行号。

```java
private void getAnd() {
    addChar();
    type = TokenType.AND;
    if (pos < inputString.length() && inputString.charAt(pos) == '&') {
        addChar();
    } else {
        ErrorHandler.getInstance().addError(new Error(ErrorType.IllegalSymbol, line));
    }
}

private void getOr() {
    addChar();
    type = TokenType.OR;
    if (pos < inputString.length() && inputString.charAt(pos) == '|') {
        addChar();
    } else {
        ErrorHandler.getInstance().addError(new Error(ErrorType.IllegalSymbol, line));
    }
}
```

### 编码后修改

部分测试点运行时出现`RE`异常，需要在分析过程中对涉及到`inputString.charAt(pos)`的部分进行越界检查。

## 语法分析

### 编码前设计

语法分析的主要任务是将token列表按照文法一步步组合为大的语法成分，在分析的同时进行异常处理。

在`PlatoCompiler`中，语法分析位于`frontend`包中，包括语法分析器`Parser`和`syntax`包（包括各种语法成分）。

#### 改写文法

给定的文法中存在左递归规则，为了实现递归下降分析，需要对原有的文法进行修改。比如对于`乘除模表达式 MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp`，可以将其改写为`MulExp -> UnaryExp ('*' | '/' | '%') UnaryExp`。

#### 递归下降分析法

语法分析器接受token序列，返回语法树的根节点`compUnit`。

对于文法中出现的每一个非终结符，分别设置一个语法结点类存储相关信息；对于stmt的多种情况，对每一个文法都定义了语法结点类（如`ReturnStmt`、`LValExpStmt`），同时继承`Stmt`抽象类；对于`VarDecl`和`ConstDecl`，同时继承`Decl`抽象类。

所有的语法结点类都需要继承语法结点抽象类`SyntaxNode`，必须实现抽象方法`print`，用于作业的输出。

`Parser`通过`parse`方法与`Compiler`进行交互。

```java
Parser parser = new Parser(tokens);
CompUnit compUnit = parser.parse();
```

语法分析程序主要是**根据文法进行递归下降**，对于每一种可能的分支进行判断，并进入对应的分支程序中，而对不符合任何语法条件的情况throw Exception。以解析`InitVal`为例：

```java
private InitVal parseInitVal() {
    if (match(TokenType.LBRACE)) {
        ArrayList<Exp> exps = new ArrayList<>();
        if (match(TokenType.RBRACE)) {
            return new InitVal(exps);
        }
        do {
            exps.add(parseExp());
        } while (match(TokenType.COMMA));
        panic(TokenType.RBRACE);
        return new InitVal(exps);
    } else if (match(TokenType.STRCON)) {
        return new InitVal(curToken(-1));
    } else {
        return new InitVal(parseExp());
    }
}
```

这里涉及到两个函数`match`和`panic`。

- match函数用来判断当前读取到token类型是否与预期的类型一致

  ```java
  public boolean match(TokenType type) {
      if (curTokenType() == type) {
          pos++;
          return true;
      } else {
          return false;
      }
  }
  ```

- panic函数用于添加语法分析时产生的异常信息

  ```java
  private void panic(TokenType type) {
      if (!match(type)) {
          doErrorException(type);
      }
  }
  
  private void doErrorException(TokenType type) {
      // i, j, k类异常要求记录前一个非终结符所在行号
      int line = curToken(-1).getLine();
      ErrorHandler errorHandler = ErrorHandler.getInstance();
      switch (type) {
          case SEMICN -> errorHandler.addError(new Error(ErrorType.SEMICNMissing, line));
          case RPARENT -> errorHandler.addError(new Error(ErrorType.RPARENTMissing, line));
          case RBRACK -> errorHandler.addError(new Error(ErrorType.RBRACKMissing, line));
          default -> throw new RuntimeException("What the f: " + type);
      }
  }
  ```

#### 预读

对于比较复杂的情况，可能需要进行预读才能判断出分支路径。

比如对于以下的文法：`Stmt -> LVal '=' Exp ';' | [Exp] ';'`，在当前的token种类为标识符时，两种情况都有可能发生，所以需要进行预读，也就是尝试解析LVal，如果之后的token类型是ASSIGN，即可判断。

```java
if (curTokenType() == TokenType.IDENFR) {
    int tempPos = pos;
    LVal lVal = parseLVal();
    if (match(TokenType.ASSIGN)) {
        if (match(TokenType.GETINTTK)) {
            panic(TokenType.LPARENT);
            panic(TokenType.RPARENT);
            panic(TokenType.SEMICN);
            return new GetintStmt(lVal);
        } else if (match(TokenType.GETCHARTK)) {
            panic(TokenType.LPARENT);
            panic(TokenType.RPARENT);
            panic(TokenType.SEMICN);
            return new GetcharStmt(lVal);
        }
        Exp exp = parseExp();
        panic(TokenType.SEMICN);
        return new LValExpStmt(lVal, exp);
    }
    pos = tempPos;
}
Exp exp = null;
if (!match(TokenType.SEMICN)) {
    exp = parseExp();
    panic(TokenType.SEMICN);
}
return new ExpStmt(exp);
```

### 编码后修改

在消除左递归文法的时候，变相更改了期望输出，例如对于算式`1+2`，文法在改写前后会有不一样的输出：

```
文法1：
AddExp -> MulExp | AddExp ('+' | '−') MulExp

INTCON 1
<MulExp> // 1
<AddExp> // 1
PLUS +
INTCON 2
<MulExp> // 2
<AddExp> // 1+2

文法2：
AddExp -> MulExp { ('+' | '−') MulExp }

INTCON 1
<MulExp> // 1
PLUS +
INTCON 2
<MulExp> // 2
<AddExp> // 1+2
```

更改后虽然不妨碍递归下降子程序的运行，但是输出少了一个`<AddExp>`，因此需要对输出逻辑进行修改。

```java
// AddExp.java
@Override
public void print() {
    mulExps.get(0).print();
    for (int i = 1; i < mulExps.size(); i++) {
        System.out.println("<AddExp>");
        System.out.println(operators.get(i - 1));
        mulExps.get(i).print();
    }
    System.out.println("<AddExp>");
}
```

## 语义分析

### 编码前设计

语义分析的主要任务是遍历语法树、维护符号表并构建中间代码。本节主要描述的是维护符号表的过程。

在`PlatoCompiler`中，语义分析的维护符号表相关代码位于`middle`包中，包括

- 访问者类`Visitor`
- 符号表类`SymbolTable`
- 符号表管理类`TableManager`
- 符号包`symbol`，包括基类`Symbol`，三种类型的符号类（`VarSymbol`变量符号类，`FuncSymbol`函数符号类，`ParamSymbol`函数形参符号类）

#### 符号表设计

符号表类`SymbolTable`的数据结构如下所示

```java
public class SymbolTable {
    private static int counter = 0;
    private final LinkedHashMap<String, Symbol> symbols = new LinkedHashMap<>();
    private final SymbolType blockType;
    private final SymbolTable parent;
    private final ArrayList<SymbolTable> children = new ArrayList<>();
}
```

`blockType`标记当前符号表是否属于一个函数的基层符号表（即全局符号表的直接子符号表）。通过`SymbolTable`包装`LinkedHashMap`实现`put`、`contains`、`remove`等方法。

这里使用`LinkedHashMap`是为了保证遍历时顺序是按照插入顺序排列的。

#### 符号表管理

符号表管理类`TableManager`采用单例模式，使得程序全局都可对其进行访问。实现如下

```java
public class TableManager {
    // 单例模式
    private static final TableManager INSTANCE1 = new TableManager();
    // 初始化为CompUnit对应的最高级的符号表
    private SymbolTable currentTable = new SymbolTable(null, null);
    // 当前处于的循环层数
    private int loopLevel = 0;
    
    private TableManager() {}
    
    public static TableManager getInstance1() {
        return INSTANCE1;
    }

    public void createTable(SymbolType blockType) {
        SymbolTable newTable = new SymbolTable(blockType, currentTable);
        currentTable.addChild(newTable);
        currentTable = newTable;
    }
    
    public void recoverTable() {
        currentTable = currentTable.getParent();
    }

    public boolean inCurrentTable(String symbolName) {
        return currentTable.containsSymbol(symbolName);
    }

    public void addSymbol(Symbol symbol) {
        currentTable.addSymbol(symbol);
    }
    
    public boolean isConstantVarSymbol(String symbolName) {
        Symbol symbol = getSymbol(symbolName);
        if (symbol instanceof VarSymbol varSymbol) {
            return varSymbol.isConstant();
        } else {
            return false;
        }
    }
}
```

`currentTable`是当前作用域的符号表，初始化为CompUnit对应的最高级的符号表。`loopLevel`为当前处于的循环层数。

解决“名字重定义”以及“名字未定义”的异常检查问题，可使用栈式符号表的结构。

每次进入一个新的作用域，调用`createTable`来创建一个新的符号表；离开作用域的时候，调用`recoverTable`将currentTable重置为其父符号表，借此隐式地实现了栈式符号表。

- 如果是进入函数定义时，需要指定`blockType`，如访问`FuncDef`时：

  ```java
  private void visitFuncDef(FuncDef funcDef) {
      SymbolType funcReturnType;
      switch (funcDef.getFuncType().getFuncType().getType()) {
          case INTTK -> funcReturnType = SymbolType.INT;
          case CHARTK -> funcReturnType = SymbolType.CHAR;
          default -> funcReturnType = SymbolType.VOID;
      }
      // 检查名字重定义
      // 构建形参符号
      // 函数形参不在Block块中，但实际上应该属于Block块中定义的变量
      tableManager.createTable(funcReturnType);
      if (funcDef.getFuncFParams() != null) {
          visitFuncFParams(funcDef.getFuncFParams());
      }
      curFuncType = funcReturnType;
      visitBlock(funcDef.getBlock());
      tableManager.recoverTable();
      curFuncType = null;
  }
  ```

- 在函数体内，进入新作用域时，创建一个`blockType = null`的符号表，如访问`BlockStmt`时：

  ```java
  private void visitBlockStmt(BlockStmt blockStmt) {
      // 访问Block中的Block时，需要另外创建符号表
      tableManager.createTable(null);
      visitBlock(blockStmt.getBlock());
      // 递归访问完Block之后，切换符号表
      tableManager.recoverTable();
  }
  ```

#### 符号查询

`TableManager`提供了两种方式来查找所要的符号。

```java
/*
 * 在符号表树中查找标识符所对应的symbol
 * 如果在本级符号表中无法查询到该symbol，则在其父节点上查找
 */
public Symbol getSymbol(String symbolName) {
    SymbolTable table = currentTable;
    while (table != null) {
        if (table.containsSymbol(symbolName)) {
            return table.getSymbol(symbolName);
        }
        table = table.getParent();
    }
    return null;
}

// 判断本级符号表中是否存在symbol
public boolean inCurrentTable(String symbolName) {
    return currentTable.containsSymbol(symbolName);
}
```

#### 符号结构

每一个`Symbol`都拥有名字和类型两种属性。对于变量符号和形参符号，`type`就是其对应的类型；对于函数符号，`type`对应的是函数的返回值类型。

```java
public class Symbol {
    private final String name;
    private final SymbolType type;
}
```

对于一个变量符号`VarSymbol`，需要额外记录其的维数及数组长度（如果维数是1）和是否为常量。

```java
public class VarSymbol extends Symbol {
    private static int counter = 0;
    private final int id;
    private final boolean isConstant;
    private final int dimension;
    // 为数组时所定义的长度：a[6] -> length = 6
    private final int length;
}
```

对于一个函数符号`FuncSymbol`，需要额外记录每个参数的类型。

```java
public class FuncSymbol extends Symbol {
    private final ArrayList<ParamSymbol> paramSymbols;
}

public class ParamSymbol {
    private final String name;
    private final SymbolType type;
    private final int dimension;
}
```

#### 编译器计算

按照文法，数组的长度和有`const`修饰的变量，在编译期就可以确定。在语法成分上，都属于`ConstExp`。

从ConstExp一路向下解析，分别使`AddExp`、`MulExp`等实现`Calculable`接口，实现`calculate`方法，在编译期进行计算（常量值或之前定义的`const`变量），否则报错。例如对`PrimaryExp`的处理：

```java
@Override
public int calculate() {
    int ans;
    if (exp != null) {
        ans = exp.calculate();
    } else if (lVal != null) {
        ans = lVal.calculate();
    } else if (number != null) {
        // number和character都是能直接得到值的语法成分
        ans = number.calculate();
    } else if (character != null) {
        ans = character.calculate();
    } else {
        throw new RuntimeException("Shouldn't reach here");
    }
    return ans;
}
```

### 编码后修改

这一步思路较为清晰，没有太多复杂和需要修改的空间。

> 以下部分是在完成中间代码生成时发现的问题及修改

考虑以下的代码片段

```c
int a = 3; //定义1
{
    int b = a;
    int a = 5; // 定义2
}
```

此时处理a的时候，原来的代码简单调用了`getSymbol`方法来查询变量`a`的定义，查询到的是定义2，这是显然不对的。

为了解决这个问题，我们可以对每个symbol对象添加属性进行标记，使得查找时只能查找到在该定义点之前出现的定义，而忽略在该定义点之后产生的定义，使得翻译`int b = a`时应该找到正确的`a`的定义，即定义1。

## 异常处理

### 编码前设计

在`PlatoCompiler`中，异常处理相关代码位于`error`包中，包括

- 异常记录类`Error`
- 异常处理类`ErrorHandler`
- 异常类型枚举类`ErrorType`

#### 枚举类

java提供的枚举类可以设置额外属性，从而实现输出正确和易读的目标

```java
public enum ErrorType {
    IllegalSymbol("a"),
    IdentRedefined("b"),
    IdentUndefined("c"),
    ParamSizeMismatch("d"),
    ParamTypeMismatch("e"),
    ReturnTypeMismatch("f"),
    ReturnMissing("g"),
    ConstAssign("h"),
    SEMICNMissing("i"),
    RPARENTMissing("j"),
    RBRACKMissing("k"),
    PrintfFmtCntNotMatch("l"),
    BreakContinueNotInLoop("m");

    private final String name;

    ErrorType(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return name;
    }
}
```

#### 异常记录

异常记录类需要记录类型与行号，通过实现`Comparable<Error>`接口实现按照行号从小到大排序。

```java
public class Error implements Comparable<Error> {
    private final ErrorType errorType;
    private final int line;

    public Error(ErrorType errorType, int line) {
        this.errorType = errorType;
        this.line = line;
    }

    public int getLine() {
        return line;
    }

    @Override
    public String toString() {
        return line + " " + errorType.toString();
    }

    @Override
    public int compareTo(Error o) {
        return this.line - o.line;
    }
}
```

#### 寻找异常

词法分析和语法分析已经可以找到部分异常，本部分主要介绍语义分析对异常的处理。

名字未定义与重定义相对简单，只需要在符号表进行查找即可。

- 参数异常：包括个数不匹配和类型不匹配

  - 个数不匹配，包括无形参而有实参、形参实参个数不相等两种情况

    ```java
    if (unaryExp.getFuncRParams() == null && !funcSymbol.getFuncParams().isEmpty()) {
        ErrorHandler.getInstance().addError(new Error(
                ErrorType.ParamSizeMismatch,
                unaryExp.getIdent().getLine()
        ));
        return;
    } else if (unaryExp.getFuncRParams() != null
            && (unaryExp.getFuncRParams().getExps().size()
            != funcSymbol.getFuncParams().size())) {
        ErrorHandler.getInstance().addError(new Error(
                ErrorType.ParamSizeMismatch,
                unaryExp.getIdent().getLine()
        ));
        return;
    }
    ```

  - 类型不匹配：实参传入时类型为`Exp`，由于不存在指针运算等，可以通过判断exp中第一个子表达式的类型来与形参类型判断，从而实现维数计算与判断。

    ```java
    // ToParam.java
    public class ToParam {
        public static ParamSymbol expToParam(Exp exp) {
            return addExpToParam(exp.getAddExp());
        }
    
        private static ParamSymbol addExpToParam(AddExp addExp) {
            return unaryExpToParam(addExp.getMulExps().get(0).getUnaryExps().get(0));
        }
    
        private static ParamSymbol unaryExpToParam(UnaryExp unaryExp) {
            if (unaryExp.getPrimaryExp() != null) {
                return primaryExpToParam(unaryExp.getPrimaryExp());
            } else if (unaryExp.getIdent() != null) {
                TableManager tableManager = TableManager.getInstance1();
                Symbol symbol = tableManager.getSymbol(unaryExp.getIdent().getContent());
                if (symbol instanceof FuncSymbol funcSymbol) {
                    return new ParamSymbol(unaryExp.getIdent().getContent(),
                            funcSymbol.getType(), 0);
                } else {
                    throw new RuntimeException("Unrecognized symbol: " +
                            unaryExp.getIdent().getContent());
                }
            } else {
                return unaryExpToParam(unaryExp.getUnaryExp());
            }
        }
    
        private static ParamSymbol primaryExpToParam(PrimaryExp primaryExp) {
            if (primaryExp.getLVal() != null) {
                return lValToParam(primaryExp.getLVal());
            } else if (primaryExp.getExp() != null) {
                return expToParam(primaryExp.getExp());
            } else if (primaryExp.getNumber() != null) {
                return new ParamSymbol(null, SymbolType.INT, 0);
            } else {
                return new ParamSymbol(null, SymbolType.CHAR, 0);
            }
        }
    
        private static ParamSymbol lValToParam(LVal lval) {
            TableManager tableManager = TableManager.getInstance1();
            VarSymbol symbol = (VarSymbol) tableManager.getSymbol(lval.getIdent().getContent());
            if (symbol == null) {
                return null;
            }
            return new ParamSymbol(
                    lval.getIdent().getContent(),
                    symbol.getType(),
                    lval.getExp() == null ? 0 : 1
            );
        }
    }
    
    // Visitor.java
    if (unaryExp.getFuncRParams() != null) {
        for (int i = 0; i < funcSymbol.getFuncParams().size(); i++) {
            ParamSymbol paramSymbol = ToParam.expToParam(
                    unaryExp.getFuncRParams().getExps().get(i));
            if (paramSymbol == null) {
                continue;
            }
            int dimension;
            if (paramSymbol.getName() == null) {
                dimension = 0;
            } else {
                Symbol symbol = tableManager.getSymbol(paramSymbol.getName());
                if (symbol.getType() == SymbolType.VOID) {
                    // void类型的函数返回值如果作为参数进行传递（传递到一个如需要int的函数参数位置）
                    // 需要报参数类型不匹配的错误。
                    dimension = -1;
                } else if (symbol instanceof VarSymbol varSymbol) {
                    /*
                    一维数组名为实参，如a[2], foo(a)，则此时funcParam将其识别为0维的左值
                    从符号表查询得到a是1维，相减得这里的实参维数是1
                     */
                    dimension = varSymbol.getDimension() - paramSymbol.getDimension();
                } else {
                    dimension = 0;
                }
            }
            // 这里处理前两种错误，归纳为形参与实参的维数不符
            if (funcSymbol.getFuncParams().get(i).getDimension() != dimension) {
                ErrorHandler.getInstance().addError(new Error(
                        ErrorType.ParamTypeMismatch,
                        unaryExp.getIdent().getLine()
                ));
                continue;
            }
            // 这里处理后两种错误
            if (funcSymbol.getFuncParams().get(i).getDimension() == 1
                    || dimension == 1) {
                // 两者均是数组
                if (funcSymbol.getFuncParams().get(i).getType() != paramSymbol.getType()) {
                    ErrorHandler.getInstance().addError(new Error(
                            ErrorType.ParamTypeMismatch,
                            unaryExp.getIdent().getLine()
                    ));
                }
            }
        }
    }
    ```

- return不匹配或缺少return：在访问完一个`Block`之后，如果当前符号表是否属于一个函数的基层符号表（即全局符号表的直接子符号表），则判断是否有return。访问`returnStmt`时，判断return是否匹配。

  ```java
  // 无返回值的函数存在不匹配的return语句
  private void visitReturnStmt(ReturnStmt returnStmt) {
      if (curFuncType == SymbolType.VOID && returnStmt.getExp() != null) {
          ErrorHandler.getInstance().addError(new Error(
                  ErrorType.ReturnTypeMismatch,
                  returnStmt.getToken().getLine()
          ));
          return;
      }
      if (returnStmt.getExp() != null) {
          visitExp(returnStmt.getExp());
      }
  }
  
  // 函数是否有返回值
  private void visitBlock(Block block) {
      for (BlockItem blockItem : block.getBlockItems()) {
          visitBlockItem(blockItem);
      }
      // 当前符号表是属于一张具有返回值的函数的
      if (TableManager.getInstance1().isFuncFirst()) {
          if (curFuncType == SymbolType.INT || curFuncType == SymbolType.CHAR) {
              ArrayList<BlockItem> items = block.getBlockItems();
              if (items.isEmpty()
                      || items.get(items.size() - 1).getStmt() == null
                      || !(items.get(items.size() - 1).getStmt() instanceof ReturnStmt)) {
                  // int或char函数缺少显性的return with value语句
                  // 这里并不关心返回的值是int型还是char型
                  ErrorHandler.getInstance().addError(new Error(
                          ErrorType.ReturnMissing, block.getEndLine()
                  ));
              }
          }
      }
  }
  ```

- 常量赋值：在符号表查找符号表，查找其是否为常量符号

  ```java
  private void visitLValExpStmt(LValExpStmt lValExpStmt) {
      visitLVal(lValExpStmt.getLVal());
      if (tableManager.isConstantVarSymbol(
              lValExpStmt.getLVal().getIdent().getContent())) {
          ErrorHandler.getInstance().addError(new Error(
                  ErrorType.ConstAssign,
                  lValExpStmt.getLVal().getIdent().getLine()
          ));
      }
      visitExp(lValExpStmt.getExp());
  }
  ```

- printf格式不匹配：检查`%[cd]`和exp的个数是否匹配即可

  ```java
  private void visitPrintfStmt(PrintfStmt printfStmt) {
      for (Exp exp : printfStmt.getExps()) {
          visitExp(exp);
      }
      int res = 0;
      Pattern pattern = Pattern.compile("%[cd]");
      Matcher matcher = pattern.matcher(printfStmt.getStringConst().getContent());
      while (matcher.find()) {
          res++;
      }
      if (res != printfStmt.getExps().size()) {
          ErrorHandler.getInstance().addError(new Error(
                  ErrorType.PrintfFmtCntNotMatch,
                  printfStmt.getToken().getLine()
          ));
      }
  }
  ```

- break和continue检查：判断当前loopLevel是否为0即可。对loopLevel的维护在访问for循环结构`ForStruct`进行。

  ```java
  private void visitForStruct(ForStruct forStruct) {
      if (forStruct.getForStmt1() != null) {
          visitForStmt(forStruct.getForStmt1());
      }
      if (forStruct.getCond() != null) {
          visitCond(forStruct.getCond());
      }
      if (forStruct.getForStmt2() != null) {
          visitForStmt(forStruct.getForStmt2());
      }
      tableManager.enterLoop();
      visitStmt(forStruct.getStmt());
      tableManager.exitLoop();
  }
  ```

### 编码后修改

在编码过程中，对函数参数的作用域出现了问题。例如，对于以下的代码

```c
int func(int a, int b) {
    int a;
    return 1;
}
```

此时是否出现了重定义？答案是肯定的。因此解析函数形参时就应该创建一个新的符号表，并将形参加入符号表中。

## 中间代码生成

### 编码前设计

本部分的主要任务是将抽象语法树（Abstract Syntax Tree，在语法阶段生成）转化为中间代码。在中间代码的选择上，`PlatoCompiler`选择使用LLVM IR为中间代码。

在`PlatoCompiler`中，中间代码生成的相关代码位于`middle`包中，主要的逻辑代码为中间代码构建类`IRBuilder`，使用方法为

```java
IRBuilder irBuilder = new IRBuilder(compUnit);
irBuilder.build();
// 构造结果存储在Module.getInstance()中
```

使用`IRData`类对中间代码生成的相关数据进行统一管理，比如当前函数、当前基本块等。`IRData`段里有设置自动插入开关，打开时创建的Instruction对象及其子类对象会自动插入当前基本块。

#### LLVM基本概念

LLVM IR文件的基本单位称为`module`，单文件编译下只有一个module。在`PlatoCompiler`的设计中，`Module`采用单例模式。

一个`module`中有多个顶层实体，如`function`和`global variable`，这可以分别对应编译单元`CompUnit`文法定义中的`{Decl}`和`{FuncDef}`；一个function中至少有一个`basicblock`，这意味着函数体声明内至少有一个基本块；一个`basicblock`中有若干`instruction`，并且都以`terminator instruction`结尾。

在LLVM中最重要的是`User-Use-Value`关系。

![图片#100% #auto](https://drinkwater-1325041233.cos.ap-guangzhou.myqcloud.com/imgs/cguserImages)

- Value是操作数类，在LLVM中，万物皆Value。每个Value都有的属性是名称、类型和user列表。
- User是使用者类，继承自Value。

```java
public class Value {
    private final ValueType valueType;
    private final ArrayList<User> userList = new ArrayList<>();
    private String name;
}

public class User extends Value {
    private ArrayList<Value> operands = new ArrayList<>();
}
```

- 基于这样的`User-Value`关系，我们可以构建`Instruction`，`BasicBlock`，`GlobalVar`等数据结构。

#### 类型系统

值类型可以分为整数类型`IntegerType`（包括`int`，`char`，`void`）、`PointerType`、`ArrayType`和`LabelType`，均继承`ValueType`基类。

```java
public class IntegerType extends ValueType {
    private final int bits;

    public IntegerType(int bits) {
        this.bits = bits;
    }
    
    public static final IntegerType VOID = new IntegerType(0);
    public static final IntegerType i1 = new IntegerType(1);
    public static final IntegerType i8 = new IntegerType(8);
    public static final IntegerType i32 = new IntegerType(32);
}

public class PointerType extends ValueType {
    // 指针指向的类型
    // 'int*'的targetType就是int
    private final ValueType targetType;
}

public class ArrayType extends ValueType {
    private final int elementNum;
    private final ValueType elementType;
}
```

#### 符号结构修改

对`VarSymbol`和`FuncSymbol`添加一个`llvmValue`属性，以方便使用符号表查询时能迅速查到相关的定义信息。

#### 类型转换

代码中存在`char`和`int`两种类型，在LLVM中可分别记为`i8`和`i32`。当`int`类型值赋给`char`类型变量时，需要进行截断。对每个操作数在计算之前均调用类型检查程序来判断是否需要进行类型转换,使用`zext`指令进行扩充，使用`trunc`指令进行截断。

#### 短路求值

只要条件判断出现“短路”，即不需要考虑后续与或参数的情况下就已经能确定值的时候，就可以进行跳转。

对`IfStmt`的基本翻译逻辑如下

```java
private void buildIfStmt(IfStmt ifStmt) {
    BasicBlock trueBlock = new BasicBlock(IRData.getBlockName());
    if (ifStmt.getStmt2() != null) {
        BasicBlock falseBlock = new BasicBlock(IRData.getBlockName());
        BasicBlock followBlock = new BasicBlock(IRData.getBlockName());
        buildCond(ifStmt.getCond(), trueBlock, falseBlock);
        IRData.setCurrentBlock(trueBlock);
        buildStmt(ifStmt.getStmt1());
        new BrInst(followBlock);
        IRData.setCurrentBlock(falseBlock);
        buildStmt(ifStmt.getStmt2());
        new BrInst(followBlock);
        IRData.setCurrentBlock(followBlock);
    } else {
        BasicBlock followBlock = new BasicBlock(IRData.getBlockName());
        buildCond(ifStmt.getCond(), trueBlock, followBlock);
        IRData.setCurrentBlock(trueBlock);
        buildStmt(ifStmt.getStmt1());
        new BrInst(followBlock);
        IRData.setCurrentBlock(followBlock);
    }
}
```

`buildCond`函数如下：

```java
private void buildCond(Cond cond, BasicBlock trueBlock, BasicBlock falseBlock) {
    buildLOrExp(cond.getLOrExp(), trueBlock, falseBlock);
}
```

解释为构建由`LOrExp`和`LAndExp`组成的式子，对于文法`LOrExp -> LOrExp '||' LAndExp `，只要其中的一个LOrExp为1则整体为1。

在前面对文法的改写中，LOrExp的文法被改写成了`LOrExp -> LAndExp {'||' LAndExp}`。此时对于每一个LAndExp，如果为真就可以直接跳转到trueBlock里，如果为假则需要判断后面的LAndExp的值，此时需要创建一个nextBlock，将后面LAndExp的判断逻辑写在nextBlock中。

```java
private void buildLOrExp(LOrExp lOrExp, BasicBlock trueBlock, BasicBlock falseBlock) {
    ArrayList<LAndExp> lAndExps = lOrExp.getlAndExps();
    for (int i = 0; i < lAndExps.size(); i++) {
        LAndExp lAndExp = lAndExps.get(i);
        if (i == lAndExps.size() - 1) {
            buildLAndExp(lAndExp, trueBlock, falseBlock);
        } else {
            BasicBlock nextBlock = new BasicBlock(IRData.getBlockName());
            buildLAndExp(lAndExp, trueBlock, nextBlock);
            IRData.setCurrentBlock(nextBlock);
        }
    }
}
```

对LAndExp的解析也可以做类似的处理。

```java
private void buildLAndExp(LAndExp lAndExp, BasicBlock trueBlock, BasicBlock falseBlock) {
    ArrayList<EqExp> eqExps = lAndExp.getEqExps();
    for (int i = 0; i < eqExps.size(); i++) {
        EqExp eqExp = eqExps.get(i);
        if (i == eqExps.size() - 1) {
            Value condition = buildEqExp(eqExp);
            new BrInst(condition, trueBlock, falseBlock);
        } else {
            BasicBlock nextBlock = new BasicBlock(IRData.getBlockName());
            Value condition = buildEqExp(eqExp);
            new BrInst(condition, nextBlock, falseBlock);
            IRData.setCurrentBlock(nextBlock);
        }
    }
}
```

#### 循环构建

对于语法树中的每一个循环，我们都可以使用四个BasicBlock来翻译，分别记为`conditionBlock`，`loopBodyBlock`，`updateBlock`和`followBlock`。

```c
int a = 0; // 位于conditionBlock的前一个block
for(i = 0; // i = 0理论上可以抽到循环前，因此它与`int a = 0`位于同一个block
    i >= 0 && i < 10; // conditionBlock
    i = i + 1 // updateBlock
   ) {
	a = a + i; // loopBodyBlock
}
// 循环体外的内容均属于followBlock
int b = a;
```

那么对循环体的翻译可以采用以下的方式。

```java
private void buildForStruct(ForStruct forStruct) {
    // forStmt和LValAssignExp本质上是一样的
    if (forStruct.getForStmt1() != null) {
        buildAssign(forStruct.getForStmt1().getLVal(),
                forStruct.getForStmt1().getExp());
    }
    BasicBlock conditionBlock = new BasicBlock(IRData.getBlockName());
    BasicBlock bodyBlock = new BasicBlock(IRData.getBlockName());
    BasicBlock updateBlock = new BasicBlock(IRData.getBlockName());
    BasicBlock followBlock = new BasicBlock(IRData.getBlockName());
    // 使用栈记录本层循环的信息
    IRData.push(new ForLoop(conditionBlock, bodyBlock, updateBlock, followBlock));
    new BrInst(conditionBlock);
    IRData.setCurrentBlock(conditionBlock);
    if (forStruct.getCond() != null) {
        buildCond(forStruct.getCond(), bodyBlock, followBlock);
    } else {
        new BrInst(bodyBlock);
    }
    IRData.setCurrentBlock(bodyBlock);
    buildStmt(forStruct.getStmt());
    new BrInst(updateBlock);
    IRData.setCurrentBlock(updateBlock);
    if (forStruct.getForStmt2() != null) {
        buildAssign(forStruct.getForStmt2().getLVal(),
                forStruct.getForStmt2().getExp());
    }
    new BrInst(conditionBlock);
    IRData.setCurrentBlock(followBlock);
    IRData.pop();
}
```

翻译break和continue指令的时候，只需要读取栈顶的循环体信息对应翻译即可。

```java
private void buildBreakStmt() {
    new BrInst(IRData.peek().getFollowBlock());
}

private void buildContinueStmt() {
    new BrInst(IRData.peek().getUpdateBlock());
}
```

### 编码后修改

基本块的命名可能与函数重名，需要分别对源代码中的名字进行处理，对源代码的函数名称添加前后缀。

对于语法成分`lVal`，同时出现在等号的左侧与右侧需要不同的llvm指令，需要分别处理。

## 目标代码生成

### 编码前设计

llvm的设计与mips较为相似，在翻译策略上可以采取逐行翻译的方式。

在`PlatoCompiler`中，目标代码生成的相关代码位于`backend`包中，主要的逻辑代码为目标代码构建类`MipsBuilder`，使用方法为

```java
MipsBuilder mipsBuilder = new MipsBuilder(Module.getInstance(), optimize);
mipsBuilder.build(optimize);
```

optimize参数表示是否在目标代码生成的过程中开启优化。

由`mipsBuilder`构建生成的mips代码序列存储在`MipsFile`类中，采用单例模式，分别存储着`.data`段和`.text`段的内容。与`IRData`类似，`MipsFile`也有自动插入开关。

本节内容未涉及寄存器分配等内容，操作全部在栈上完成，使用的寄存器有`a1-a3`，`v0-v1`，`k0-k1`，`sp`，`ra`等。

#### 函数初始化

对于每一个LLVM中的`Function`对象（包括main函数），在进行内容翻译，首先需要进行初始化，对函数内部有左值的llvm指令分配栈空间。如果有参数，在栈上需要留下参数的空间。

预留栈空间可以通过添加Value到stackOffset的映射来实现。

```java
private void buildFunction(Function function) {
    currentFunction = function;
    var2Offset = new HashMap<>();
    curStackOffset = 0;
    var2reg = optimizeOn ? new HashMap<>(function.getVar2reg()) : new HashMap<>();
    new Label("func_" + function.getName().substring(1));
    for (int i = 0; i < function.getFuncParams().size(); i++) {
        curStackOffset -= 4;
        if (i < 3) {
            // a1, a2, a3
            // 添加Value向寄存器的映射，此处省略
        }
        var2Offset.put(function.getFuncParams().get(i), curStackOffset);
    }
    for (BasicBlock block : function.getBasicBlocks()) {
        for (Instruction instruction : block.getInstructions()) {
            if (!instruction.getName().isEmpty()
                    && !(instruction instanceof MoveInst)
                    && !var2reg.containsKey(instruction)
                    && !var2Offset.containsKey(instruction)) {
                curStackOffset -= 4;
                var2Offset.put(instruction, curStackOffset);
            } else if (instruction instanceof MoveInst moveInst) {
                if (!var2reg.containsKey(moveInst.getToValue())
                        && !var2Offset.containsKey(moveInst.getToValue())) {
                    curStackOffset -= 4;
                    var2Offset.put(moveInst.getToValue(), curStackOffset);
                }
            }
        }
    }
    for (BasicBlock block : function.getBasicBlocks()) {
        buildBasicBlock(block);
    }
}
```

#### .data段

.data段主要存储的是全局变量和字符串，分别抽象为`Word`和`Asciiz`类。

.asciiz用来存储llvm阶段分析得到的匿名常量字符串（与用户定义的`char s[6] = "Hello"`相区分）。

```java
public class Asciiz extends GlobalAssembly {
    private final String name;
    private final String content;
}
```

`Word`类用来存储单个或连续的大小为4字节的空间（为方便设计，`int`和`char`均占4字节）。对于初始元素数量小于数组长度的情况，通过`.word`和`.space`的配合进行初始化。

```assembly
# int a[10] = {2};
a: .word 2 # existed definition
   .space 36 # zeroinitializer
```

#### 扩展与截断

在中间代码生成的过程中产生了一些`zext`和`trunc`指令。

- `PlatoCompiler`假设`i1`、`i8`、`i32`在mips均占4字节，所以对于`zext`可以不用特别处理，直接当`move`看待即可。在后面的优化中，我们可以删去所有的`zext`指令；

- `trunc`转换为按位与即可，例如将`i32`转换为`i8`的代码片段中，截取低八位即可。

  ```assembly
  # %v1 = call i32 @getint()
  li $v0, 5
  syscall
  move $t0, $v0
  # %v2 = mul i32 %v1, 2
  addu $t0, $t0, $t0
  # %v3 = trunc i32 %v2 to i8
  # 截取低八位
  andi $t0, $t0, 255
  ```

#### 函数调用

LLVM将函数调用总结为`call`指令，并未涉及到内存管理。在将call翻译成mips指令时，需要按照以下步骤进行：

- 保存已经分配的全局寄存器值在栈中，让栈向下增长
- 将前三个参数保存到`$a1-$a3`寄存器上，并为其在栈上预留空间
- 将第四个及之后的参数都保存在栈上
- 将`$sp`的值以及本函数的返回地址保存在栈上
- 将`$sp`指向函数第一个参数所在栈的位置，`jal`跳转到被调用函数
- 恢复现场，从栈中读取栈指针的原值并恢复栈指针的位置，恢复返回地址`$ra`，恢复全局寄存器的值

#### 跳转指令

对于以下的代码片段

```
%v5 = icmp sgt i32 %v4, 2
br i1 %v5, label %b6, label %b7
```

我们可以将其化为两个mips指令，即`bgt $t0, 2, main_bb6; j main_bb7`，从而省略了sgt的步骤。

### 编码后修改

为了方便debug，在.text段中添加了`Comment`类，用于标记mips指令片段对应的llvm代码。

函数名和基本块名均使用mips中的标签`Label`来管理。为了防止重名，对函数名进行了前缀`func_`修饰，对基本块名添加了前缀`{函数名}_`修饰。

## 代码优化

### 编码前设计

`PlatoCompiler`在中间代码和目标代码都进行了一定程度的优化，相关代码分别位于`optimize`包和`backend.utils`包内。

本节对代码优化方法进行简要的列举，具体思路见另外提交的优化文档。

#### 机器无关优化

- Mem2Reg：每个变量仅被赋值一次
- 计算CFG图：用于消除phi、基本块合并、基本块重排等操作
- 代码删除：删除死代码（无法被执行的代码）与无用代码（对程序运行没有影响）的代码，删除无用函数
- 函数内联：将函数嵌入到调用地点，降低栈帧保存开销
- 全局变量本地化：将符合要求的全局变量变为本地变量，调用其他方法进行优化
- GVN：消除公共表达式；消除不可能到达的基本块
- 常量折叠：在编译时计算其操作数已知是常数、或满足恒等式的表达式
- const提取：将const变量替换为编译期已计算出来的常量值
- 输出优化：对连续的输出进行拼接优化
- 基本块合并与重排列：减少跳转指令执行次数
- 消Phi：将phi转化为并行的move指令

#### 机器相关优化

- 窥孔优化：消除多余的move指令和j指令
- 运算强度削弱：乘除法优化，降低周期数
- 寄存器分配：通过引用计数与图着色结合分配寄存器

### 编码后修改

使用GVN替换表达式时，如果表达式为`call`指令，需要判断其是否具有副作用，有副作用的`call`指令是无法被替换的。
